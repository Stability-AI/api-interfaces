// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stability_api/platform/generation/v1/generation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Stabilityai_Platformapis_Generation_V1_FinishReason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case null // = 0
  case length // = 1
  case stop // = 2
  case error // = 3
  case filter // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .null
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 1: self = .length
    case 2: self = .stop
    case 3: self = .error
    case 4: self = .filter
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .null: return 0
    case .length: return 1
    case .stop: return 2
    case .error: return 3
    case .filter: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_FinishReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_FinishReason] = [
    .null,
    .length,
    .stop,
    .error,
    .filter,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_ArtifactType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case artifactNone // = 0
  case artifactImage // = 1
  case artifactVideo // = 2
  case artifactText // = 3
  case artifactTokens // = 4
  case artifactEmbedding // = 5
  case artifactClassifications // = 6
  case artifactMask // = 7
  case artifactLatent // = 8
  case artifactTensor // = 9
  case artifactDepth // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .artifactNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .artifactNone
    case 1: self = .artifactImage
    case 2: self = .artifactVideo
    case 3: self = .artifactText
    case 4: self = .artifactTokens
    case 5: self = .artifactEmbedding
    case 6: self = .artifactClassifications
    case 7: self = .artifactMask
    case 8: self = .artifactLatent
    case 9: self = .artifactTensor
    case 10: self = .artifactDepth
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .artifactNone: return 0
    case .artifactImage: return 1
    case .artifactVideo: return 2
    case .artifactText: return 3
    case .artifactTokens: return 4
    case .artifactEmbedding: return 5
    case .artifactClassifications: return 6
    case .artifactMask: return 7
    case .artifactLatent: return 8
    case .artifactTensor: return 9
    case .artifactDepth: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_ArtifactType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_ArtifactType] = [
    .artifactNone,
    .artifactImage,
    .artifactVideo,
    .artifactText,
    .artifactTokens,
    .artifactEmbedding,
    .artifactClassifications,
    .artifactMask,
    .artifactLatent,
    .artifactTensor,
    .artifactDepth,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_MaskedAreaInit: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case zero // = 0
  case random // = 1
  case original // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .zero
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .zero
    case 1: self = .random
    case 2: self = .original
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .zero: return 0
    case .random: return 1
    case .original: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_MaskedAreaInit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_MaskedAreaInit] = [
    .zero,
    .random,
    .original,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_WeightMethod: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case textEncoder // = 0
  case crossAttention // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .textEncoder
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .textEncoder
    case 1: self = .crossAttention
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .textEncoder: return 0
    case .crossAttention: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_WeightMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_WeightMethod] = [
    .textEncoder,
    .crossAttention,
  ]
}

#endif  // swift(>=4.2)

/// DiffusionSampler identifies which sampler to use for Diffusion, and represents
/// the internal set of supported samplers.
enum Stabilityai_Platformapis_Generation_V1_DiffusionSampler: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case samplerDdim // = 0
  case samplerDdpm // = 1
  case samplerKEuler // = 2
  case samplerKEulerAncestral // = 3
  case samplerKHeun // = 4
  case samplerKDpm2 // = 5
  case samplerKDpm2Ancestral // = 6
  case samplerKLms // = 7
  case samplerKDpmpp2SAncestral // = 8
  case samplerKDpmpp2M // = 9
  case samplerKDpmppSde // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .samplerDdim
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .samplerDdim
    case 1: self = .samplerDdpm
    case 2: self = .samplerKEuler
    case 3: self = .samplerKEulerAncestral
    case 4: self = .samplerKHeun
    case 5: self = .samplerKDpm2
    case 6: self = .samplerKDpm2Ancestral
    case 7: self = .samplerKLms
    case 8: self = .samplerKDpmpp2SAncestral
    case 9: self = .samplerKDpmpp2M
    case 10: self = .samplerKDpmppSde
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .samplerDdim: return 0
    case .samplerDdpm: return 1
    case .samplerKEuler: return 2
    case .samplerKEulerAncestral: return 3
    case .samplerKHeun: return 4
    case .samplerKDpm2: return 5
    case .samplerKDpm2Ancestral: return 6
    case .samplerKLms: return 7
    case .samplerKDpmpp2SAncestral: return 8
    case .samplerKDpmpp2M: return 9
    case .samplerKDpmppSde: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_DiffusionSampler: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_DiffusionSampler] = [
    .samplerDdim,
    .samplerDdpm,
    .samplerKEuler,
    .samplerKEulerAncestral,
    .samplerKHeun,
    .samplerKDpm2,
    .samplerKDpm2Ancestral,
    .samplerKLms,
    .samplerKDpmpp2SAncestral,
    .samplerKDpmpp2M,
    .samplerKDpmppSde,
  ]
}

#endif  // swift(>=4.2)

/// Future, unimplemented.
enum Stabilityai_Platformapis_Generation_V1_Upscaler: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rgb // = 0
  case gfpgan // = 1
  case esrgan // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .rgb
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rgb
    case 1: self = .gfpgan
    case 2: self = .esrgan
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rgb: return 0
    case .gfpgan: return 1
    case .esrgan: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_Upscaler: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_Upscaler] = [
    .rgb,
    .gfpgan,
    .esrgan,
  ]
}

#endif  // swift(>=4.2)

/// Presets for CLIP guidance.
enum Stabilityai_Platformapis_Generation_V1_GuidancePreset: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case simple // = 1
  case fastBlue // = 2
  case fastGreen // = 3
  case slow // = 4
  case slower // = 5
  case slowest // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .simple
    case 2: self = .fastBlue
    case 3: self = .fastGreen
    case 4: self = .slow
    case 5: self = .slower
    case 6: self = .slowest
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .simple: return 1
    case .fastBlue: return 2
    case .fastGreen: return 3
    case .slow: return 4
    case .slower: return 5
    case .slowest: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_GuidancePreset: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_GuidancePreset] = [
    .none,
    .simple,
    .fastBlue,
    .fastGreen,
    .slow,
    .slower,
    .slowest,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_ModelArchitecture: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case clipVit // = 1
  case clipResnet // = 2
  case ldm // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .clipVit
    case 2: self = .clipResnet
    case 3: self = .ldm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .clipVit: return 1
    case .clipResnet: return 2
    case .ldm: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_ModelArchitecture: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_ModelArchitecture] = [
    .none,
    .clipVit,
    .clipResnet,
    .ldm,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_Action: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case passthrough // = 0
  case regenerateDuplicate // = 1
  case regenerate // = 2
  case obfuscateDuplicate // = 3
  case obfuscate // = 4
  case discard // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .passthrough
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .passthrough
    case 1: self = .regenerateDuplicate
    case 2: self = .regenerate
    case 3: self = .obfuscateDuplicate
    case 4: self = .obfuscate
    case 5: self = .discard
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .passthrough: return 0
    case .regenerateDuplicate: return 1
    case .regenerate: return 2
    case .obfuscateDuplicate: return 3
    case .obfuscate: return 4
    case .discard: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_Action] = [
    .passthrough,
    .regenerateDuplicate,
    .regenerate,
    .obfuscateDuplicate,
    .obfuscate,
    .discard,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_ClassifierMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case clsfrModeZeroshot // = 0

  ///CLSFR_MODE_ODDSRATIO = 2;
  case clsfrModeMulticlass // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .clsfrModeZeroshot
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .clsfrModeZeroshot
    case 1: self = .clsfrModeMulticlass
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .clsfrModeZeroshot: return 0
    case .clsfrModeMulticlass: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_ClassifierMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_ClassifierMode] = [
    .clsfrModeZeroshot,
    .clsfrModeMulticlass,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_InterpolateMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case interpolateLinear // = 0
  case interpolateRife // = 1
  case interpolateVaeLinear // = 2
  case interpolateVaeSlerp // = 3
  case interpolateFilm // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .interpolateLinear
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .interpolateLinear
    case 1: self = .interpolateRife
    case 2: self = .interpolateVaeLinear
    case 3: self = .interpolateVaeSlerp
    case 4: self = .interpolateFilm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .interpolateLinear: return 0
    case .interpolateRife: return 1
    case .interpolateVaeLinear: return 2
    case .interpolateVaeSlerp: return 3
    case .interpolateFilm: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_InterpolateMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_InterpolateMode] = [
    .interpolateLinear,
    .interpolateRife,
    .interpolateVaeLinear,
    .interpolateVaeSlerp,
    .interpolateFilm,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_BorderMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// reflect image values across the border
  case borderReflect // = 0

  /// replicate border values outside the image
  case borderReplicate // = 1

  /// wrap around / tile the image values
  case borderWrap // = 2

  /// use 0 for locations outside the image
  case borderZero // = 3

  /// prefill border areas with values matching the colors around the area
  case borderPrefill // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .borderReflect
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .borderReflect
    case 1: self = .borderReplicate
    case 2: self = .borderWrap
    case 3: self = .borderZero
    case 4: self = .borderPrefill
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .borderReflect: return 0
    case .borderReplicate: return 1
    case .borderWrap: return 2
    case .borderZero: return 3
    case .borderPrefill: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_BorderMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_BorderMode] = [
    .borderReflect,
    .borderReplicate,
    .borderWrap,
    .borderZero,
    .borderPrefill,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_ColorMatchMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// match hue, saturation, and value histograms
  case colorMatchHsv // = 0

  /// match lightness, a, and b histograms
  case colorMatchLab // = 1

  /// match red, green, and blue histograms
  case colorMatchRgb // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .colorMatchHsv
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .colorMatchHsv
    case 1: self = .colorMatchLab
    case 2: self = .colorMatchRgb
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .colorMatchHsv: return 0
    case .colorMatchLab: return 1
    case .colorMatchRgb: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_ColorMatchMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_ColorMatchMode] = [
    .colorMatchHsv,
    .colorMatchLab,
    .colorMatchRgb,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_CameraType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Perspective camera
  case cameraPerspective // = 0

  /// Orthographic camera. Well suited for isometric animations
  case cameraOrthographic // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .cameraPerspective
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cameraPerspective
    case 1: self = .cameraOrthographic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cameraPerspective: return 0
    case .cameraOrthographic: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_CameraType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_CameraType] = [
    .cameraPerspective,
    .cameraOrthographic,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_RenderMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case renderMesh // = 0
  case renderPointcloud // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .renderMesh
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .renderMesh
    case 1: self = .renderPointcloud
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .renderMesh: return 0
    case .renderPointcloud: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_RenderMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_RenderMode] = [
    .renderMesh,
    .renderPointcloud,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_AssetAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case assetPut // = 0
  case assetGet // = 1
  case assetDelete // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .assetPut
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .assetPut
    case 1: self = .assetGet
    case 2: self = .assetDelete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .assetPut: return 0
    case .assetGet: return 1
    case .assetDelete: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_AssetAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_AssetAction] = [
    .assetPut,
    .assetGet,
    .assetDelete,
  ]
}

#endif  // swift(>=4.2)

/// AssetUse defines how the asset is used within a project.  This enum matches
/// the values the project proto.
enum Stabilityai_Platformapis_Generation_V1_AssetUse: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Asset does not have use defined
  case undefined // = 0

  /// Asset is used as an input for the project
  case input // = 1

  /// Asset is an output from the project
  case output // = 2

  /// Asset is an output from an intermediate step of the project
  case intermediate // = 3

  /// Asset is used as the project file for the project
  case project // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .input
    case 2: self = .output
    case 3: self = .intermediate
    case 4: self = .project
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .input: return 1
    case .output: return 2
    case .intermediate: return 3
    case .project: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_AssetUse: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_AssetUse] = [
    .undefined,
    .input,
    .output,
    .intermediate,
    .project,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Generation_V1_StageAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case pass // = 0
  case discard // = 1
  case `return` // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .pass
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pass
    case 1: self = .discard
    case 2: self = .return
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pass: return 0
    case .discard: return 1
    case .return: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Generation_V1_StageAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Generation_V1_StageAction] = [
    .pass,
    .discard,
    .return,
  ]
}

#endif  // swift(>=4.2)

/// Generally, a GPT BPE 16-bit token, paired with an optional string representation.
struct Stabilityai_Platformapis_Generation_V1_Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _text: String? = nil
}

/// Sequence of tokens, paired with the id of the tokenizer used to generate them.
struct Stabilityai_Platformapis_Generation_V1_Tokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokens: [Stabilityai_Platformapis_Generation_V1_Token] = []

  var tokenizerID: String {
    get {return _tokenizerID ?? String()}
    set {_tokenizerID = newValue}
  }
  /// Returns true if `tokenizerID` has been explicitly set.
  var hasTokenizerID: Bool {return self._tokenizerID != nil}
  /// Clears the value of `tokenizerID`. Subsequent reads from it will return its default value.
  mutating func clearTokenizerID() {self._tokenizerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tokenizerID: String? = nil
}

/// A tangible Artifact, such as an image, video, or text that is used for input
/// or output.
struct Stabilityai_Platformapis_Generation_V1_Artifact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var type: Stabilityai_Platformapis_Generation_V1_ArtifactType = .artifactNone

  /// MIME type identifier, e.g. "image/png"
  var mime: String = String()

  /// Magic number, e.g. "PNG"
  var magic: String {
    get {return _magic ?? String()}
    set {_magic = newValue}
  }
  /// Returns true if `magic` has been explicitly set.
  var hasMagic: Bool {return self._magic != nil}
  /// Clears the value of `magic`. Subsequent reads from it will return its default value.
  mutating func clearMagic() {self._magic = nil}

  var data: Stabilityai_Platformapis_Generation_V1_Artifact.OneOf_Data? = nil

  /// Binary data, e.g. PNG image
  var binary: Data {
    get {
      if case .binary(let v)? = data {return v}
      return Data()
    }
    set {data = .binary(newValue)}
  }

  /// Text data, e.g. text prompt
  var text: String {
    get {
      if case .text(let v)? = data {return v}
      return String()
    }
    set {data = .text(newValue)}
  }

  /// Tokenized text data, e.g. GPT tokens
  var tokens: Stabilityai_Platformapis_Generation_V1_Tokens {
    get {
      if case .tokens(let v)? = data {return v}
      return Stabilityai_Platformapis_Generation_V1_Tokens()
    }
    set {data = .tokens(newValue)}
  }

  var classifier: Stabilityai_Platformapis_Generation_V1_ClassifierParameters {
    get {
      if case .classifier(let v)? = data {return v}
      return Stabilityai_Platformapis_Generation_V1_ClassifierParameters()
    }
    set {data = .classifier(newValue)}
  }

  /// torch.Tensor:
  var tensor: Tensors_Tensor {
    get {
      if case .tensor(let v)? = data {return v}
      return Tensors_Tensor()
    }
    set {data = .tensor(newValue)}
  }

  /// Index of this artifact in input/output list
  var index: UInt32 = 0

  /// Reason for finishing, if applicable
  var finishReason: Stabilityai_Platformapis_Generation_V1_FinishReason = .null

  /// Seed used to generate this artifact
  var seed: UInt32 = 0

  /// UUIDv4 of the artifact, used for asset lookup
  var uuid: String = String()

  /// Size of the artifact in bytes
  var size: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    /// Binary data, e.g. PNG image
    case binary(Data)
    /// Text data, e.g. text prompt
    case text(String)
    /// Tokenized text data, e.g. GPT tokens
    case tokens(Stabilityai_Platformapis_Generation_V1_Tokens)
    case classifier(Stabilityai_Platformapis_Generation_V1_ClassifierParameters)
    /// torch.Tensor:
    case tensor(Tensors_Tensor)

  #if !swift(>=4.1)
    static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Artifact.OneOf_Data, rhs: Stabilityai_Platformapis_Generation_V1_Artifact.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.binary, .binary): return {
        guard case .binary(let l) = lhs, case .binary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokens, .tokens): return {
        guard case .tokens(let l) = lhs, case .tokens(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.classifier, .classifier): return {
        guard case .classifier(let l) = lhs, case .classifier(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tensor, .tensor): return {
        guard case .tensor(let l) = lhs, case .tensor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _magic: String? = nil
}

/// A set of parameters for each individual Prompt.
struct Stabilityai_Platformapis_Generation_V1_PromptParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// deprecated, no longer used
  var init_p: Bool {
    get {return _init_p ?? false}
    set {_init_p = newValue}
  }
  /// Returns true if `init_p` has been explicitly set.
  var hasInit_p: Bool {return self._init_p != nil}
  /// Clears the value of `init_p`. Subsequent reads from it will return its default value.
  mutating func clearInit_p() {self._init_p = nil}

  var weight: Float {
    get {return _weight ?? 0}
    set {_weight = newValue}
  }
  /// Returns true if `weight` has been explicitly set.
  var hasWeight: Bool {return self._weight != nil}
  /// Clears the value of `weight`. Subsequent reads from it will return its default value.
  mutating func clearWeight() {self._weight = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _init_p: Bool? = nil
  fileprivate var _weight: Float? = nil
}

/// A Prompt is a special type of Artifact that is used to generate an output.
/// There can be multiple Prompts that affect the same output. Currently, the
/// only Prompts supported are:
///   - Text (singular)
///   - Init Image (singular, optional, type ARTIFACT_IMAGE)
///   - Mask (singular, optional, type ARTIFACT_MASK)
///   - Depth (singular, optional, type ARTIFACT_DEPTH)
struct Stabilityai_Platformapis_Generation_V1_Prompt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameters: Stabilityai_Platformapis_Generation_V1_PromptParameters {
    get {return _parameters ?? Stabilityai_Platformapis_Generation_V1_PromptParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  mutating func clearParameters() {self._parameters = nil}

  var prompt: Stabilityai_Platformapis_Generation_V1_Prompt.OneOf_Prompt? = nil

  var text: String {
    get {
      if case .text(let v)? = prompt {return v}
      return String()
    }
    set {prompt = .text(newValue)}
  }

  var tokens: Stabilityai_Platformapis_Generation_V1_Tokens {
    get {
      if case .tokens(let v)? = prompt {return v}
      return Stabilityai_Platformapis_Generation_V1_Tokens()
    }
    set {prompt = .tokens(newValue)}
  }

  var artifact: Stabilityai_Platformapis_Generation_V1_Artifact {
    get {
      if case .artifact(let v)? = prompt {return v}
      return Stabilityai_Platformapis_Generation_V1_Artifact()
    }
    set {prompt = .artifact(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Prompt: Equatable {
    case text(String)
    case tokens(Stabilityai_Platformapis_Generation_V1_Tokens)
    case artifact(Stabilityai_Platformapis_Generation_V1_Artifact)

  #if !swift(>=4.1)
    static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Prompt.OneOf_Prompt, rhs: Stabilityai_Platformapis_Generation_V1_Prompt.OneOf_Prompt) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokens, .tokens): return {
        guard case .tokens(let l) = lhs, case .tokens(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.artifact, .artifact): return {
        guard case .artifact(let l) = lhs, case .artifact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _parameters: Stabilityai_Platformapis_Generation_V1_PromptParameters? = nil
}

/// Parameters that affect the behavior of the sampler, typically used for CFG.
struct Stabilityai_Platformapis_Generation_V1_SamplerParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eta: Float {
    get {return _eta ?? 0}
    set {_eta = newValue}
  }
  /// Returns true if `eta` has been explicitly set.
  var hasEta: Bool {return self._eta != nil}
  /// Clears the value of `eta`. Subsequent reads from it will return its default value.
  mutating func clearEta() {self._eta = nil}

  var samplingSteps: UInt64 {
    get {return _samplingSteps ?? 0}
    set {_samplingSteps = newValue}
  }
  /// Returns true if `samplingSteps` has been explicitly set.
  var hasSamplingSteps: Bool {return self._samplingSteps != nil}
  /// Clears the value of `samplingSteps`. Subsequent reads from it will return its default value.
  mutating func clearSamplingSteps() {self._samplingSteps = nil}

  var latentChannels: UInt64 {
    get {return _latentChannels ?? 0}
    set {_latentChannels = newValue}
  }
  /// Returns true if `latentChannels` has been explicitly set.
  var hasLatentChannels: Bool {return self._latentChannels != nil}
  /// Clears the value of `latentChannels`. Subsequent reads from it will return its default value.
  mutating func clearLatentChannels() {self._latentChannels = nil}

  var downsamplingFactor: UInt64 {
    get {return _downsamplingFactor ?? 0}
    set {_downsamplingFactor = newValue}
  }
  /// Returns true if `downsamplingFactor` has been explicitly set.
  var hasDownsamplingFactor: Bool {return self._downsamplingFactor != nil}
  /// Clears the value of `downsamplingFactor`. Subsequent reads from it will return its default value.
  mutating func clearDownsamplingFactor() {self._downsamplingFactor = nil}

  var cfgScale: Float {
    get {return _cfgScale ?? 0}
    set {_cfgScale = newValue}
  }
  /// Returns true if `cfgScale` has been explicitly set.
  var hasCfgScale: Bool {return self._cfgScale != nil}
  /// Clears the value of `cfgScale`. Subsequent reads from it will return its default value.
  mutating func clearCfgScale() {self._cfgScale = nil}

  /// defaults to 0.99
  var initNoiseScale: Float {
    get {return _initNoiseScale ?? 0}
    set {_initNoiseScale = newValue}
  }
  /// Returns true if `initNoiseScale` has been explicitly set.
  var hasInitNoiseScale: Bool {return self._initNoiseScale != nil}
  /// Clears the value of `initNoiseScale`. Subsequent reads from it will return its default value.
  mutating func clearInitNoiseScale() {self._initNoiseScale = nil}

  /// defaults to 0.99
  var stepNoiseScale: Float {
    get {return _stepNoiseScale ?? 0}
    set {_stepNoiseScale = newValue}
  }
  /// Returns true if `stepNoiseScale` has been explicitly set.
  var hasStepNoiseScale: Bool {return self._stepNoiseScale != nil}
  /// Clears the value of `stepNoiseScale`. Subsequent reads from it will return its default value.
  mutating func clearStepNoiseScale() {self._stepNoiseScale = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eta: Float? = nil
  fileprivate var _samplingSteps: UInt64? = nil
  fileprivate var _latentChannels: UInt64? = nil
  fileprivate var _downsamplingFactor: UInt64? = nil
  fileprivate var _cfgScale: Float? = nil
  fileprivate var _initNoiseScale: Float? = nil
  fileprivate var _stepNoiseScale: Float? = nil
}

/// Unused, but reserved for future use. Adjustments to the latents after
/// initialization.
struct Stabilityai_Platformapis_Generation_V1_ConditionerParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vectorAdjustPrior: String {
    get {return _vectorAdjustPrior ?? String()}
    set {_vectorAdjustPrior = newValue}
  }
  /// Returns true if `vectorAdjustPrior` has been explicitly set.
  var hasVectorAdjustPrior: Bool {return self._vectorAdjustPrior != nil}
  /// Clears the value of `vectorAdjustPrior`. Subsequent reads from it will return its default value.
  mutating func clearVectorAdjustPrior() {self._vectorAdjustPrior = nil}

  var conditioner: Stabilityai_Platformapis_Generation_V1_Model {
    get {return _conditioner ?? Stabilityai_Platformapis_Generation_V1_Model()}
    set {_conditioner = newValue}
  }
  /// Returns true if `conditioner` has been explicitly set.
  var hasConditioner: Bool {return self._conditioner != nil}
  /// Clears the value of `conditioner`. Subsequent reads from it will return its default value.
  mutating func clearConditioner() {self._conditioner = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vectorAdjustPrior: String? = nil
  fileprivate var _conditioner: Stabilityai_Platformapis_Generation_V1_Model? = nil
}

/// When does this schedule definition apply?
struct Stabilityai_Platformapis_Generation_V1_ScheduleParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0.0 to 1.0
  var start: Float {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  /// 0.0 to 1.0
  var end: Float {
    get {return _end ?? 0}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  /// float value to apply on this schedule
  var value: Float {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _start: Float? = nil
  fileprivate var _end: Float? = nil
  fileprivate var _value: Float? = nil
}

/// Parameters that apply to this block of the schedule.
struct Stabilityai_Platformapis_Generation_V1_StepParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scaledStep: Float = 0

  var sampler: Stabilityai_Platformapis_Generation_V1_SamplerParameters {
    get {return _sampler ?? Stabilityai_Platformapis_Generation_V1_SamplerParameters()}
    set {_sampler = newValue}
  }
  /// Returns true if `sampler` has been explicitly set.
  var hasSampler: Bool {return self._sampler != nil}
  /// Clears the value of `sampler`. Subsequent reads from it will return its default value.
  mutating func clearSampler() {self._sampler = nil}

  var schedule: Stabilityai_Platformapis_Generation_V1_ScheduleParameters {
    get {return _schedule ?? Stabilityai_Platformapis_Generation_V1_ScheduleParameters()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {self._schedule = nil}

  var guidance: Stabilityai_Platformapis_Generation_V1_GuidanceParameters {
    get {return _guidance ?? Stabilityai_Platformapis_Generation_V1_GuidanceParameters()}
    set {_guidance = newValue}
  }
  /// Returns true if `guidance` has been explicitly set.
  var hasGuidance: Bool {return self._guidance != nil}
  /// Clears the value of `guidance`. Subsequent reads from it will return its default value.
  mutating func clearGuidance() {self._guidance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sampler: Stabilityai_Platformapis_Generation_V1_SamplerParameters? = nil
  fileprivate var _schedule: Stabilityai_Platformapis_Generation_V1_ScheduleParameters? = nil
  fileprivate var _guidance: Stabilityai_Platformapis_Generation_V1_GuidanceParameters? = nil
}

struct Stabilityai_Platformapis_Generation_V1_Model {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var architecture: Stabilityai_Platformapis_Generation_V1_ModelArchitecture = .none

  var publisher: String = String()

  var dataset: String = String()

  var version: Float = 0

  var semanticVersion: String = String()

  var alias: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stabilityai_Platformapis_Generation_V1_CutoutParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Nested cutouts, unsupported
  var cutouts: [Stabilityai_Platformapis_Generation_V1_CutoutParameters] = []

  /// 0 to n, usually 8 to 32, 0 inner
  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  /// 0.0 to 1.0, defaults to 0.2
  var gray: Float {
    get {return _gray ?? 0}
    set {_gray = newValue}
  }
  /// Returns true if `gray` has been explicitly set.
  var hasGray: Bool {return self._gray != nil}
  /// Clears the value of `gray`. Subsequent reads from it will return its default value.
  mutating func clearGray() {self._gray = nil}

  /// percentage of cutouts to blur
  var blur: Float {
    get {return _blur ?? 0}
    set {_blur = newValue}
  }
  /// Returns true if `blur` has been explicitly set.
  var hasBlur: Bool {return self._blur != nil}
  /// Clears the value of `blur`. Subsequent reads from it will return its default value.
  mutating func clearBlur() {self._blur = nil}

  /// defaults to inner: 0.5, outer: 0.0
  var sizePower: Float {
    get {return _sizePower ?? 0}
    set {_sizePower = newValue}
  }
  /// Returns true if `sizePower` has been explicitly set.
  var hasSizePower: Bool {return self._sizePower != nil}
  /// Clears the value of `sizePower`. Subsequent reads from it will return its default value.
  mutating func clearSizePower() {self._sizePower = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _count: UInt32? = nil
  fileprivate var _gray: Float? = nil
  fileprivate var _blur: Float? = nil
  fileprivate var _sizePower: Float? = nil
}

/// GuidanceScheduleParameters are used to define a schedule for CLIP guidance, and
/// are used to define the behavior of the guidance over time. They are relative
/// to the total number of steps, and are scaled to the number of steps in the
/// current run.
struct Stabilityai_Platformapis_Generation_V1_GuidanceScheduleParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var duration: Float = 0

  var value: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Parameters that affect the behavior of the guidance, typically used for CLIP.
/// We can specify more than one model, and the guidance will be a weighted sum
/// of the models.
struct Stabilityai_Platformapis_Generation_V1_GuidanceInstanceParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// models to use for this set
  var models: [Stabilityai_Platformapis_Generation_V1_Model] {
    get {return _storage._models}
    set {_uniqueStorage()._models = newValue}
  }

  /// 0.0 to 1.0, usually 0.05 to 0.225
  var guidanceStrength: Float {
    get {return _storage._guidanceStrength ?? 0}
    set {_uniqueStorage()._guidanceStrength = newValue}
  }
  /// Returns true if `guidanceStrength` has been explicitly set.
  var hasGuidanceStrength: Bool {return _storage._guidanceStrength != nil}
  /// Clears the value of `guidanceStrength`. Subsequent reads from it will return its default value.
  mutating func clearGuidanceStrength() {_uniqueStorage()._guidanceStrength = nil}

  /// when to apply guidance
  var schedule: [Stabilityai_Platformapis_Generation_V1_GuidanceScheduleParameters] {
    get {return _storage._schedule}
    set {_uniqueStorage()._schedule = newValue}
  }

  /// cutout parameters
  var cutouts: Stabilityai_Platformapis_Generation_V1_CutoutParameters {
    get {return _storage._cutouts ?? Stabilityai_Platformapis_Generation_V1_CutoutParameters()}
    set {_uniqueStorage()._cutouts = newValue}
  }
  /// Returns true if `cutouts` has been explicitly set.
  var hasCutouts: Bool {return _storage._cutouts != nil}
  /// Clears the value of `cutouts`. Subsequent reads from it will return its default value.
  mutating func clearCutouts() {_uniqueStorage()._cutouts = nil}

  /// prompt to use for guidance
  var prompt: Stabilityai_Platformapis_Generation_V1_Prompt {
    get {return _storage._prompt ?? Stabilityai_Platformapis_Generation_V1_Prompt()}
    set {_uniqueStorage()._prompt = newValue}
  }
  /// Returns true if `prompt` has been explicitly set.
  var hasPrompt: Bool {return _storage._prompt != nil}
  /// Clears the value of `prompt`. Subsequent reads from it will return its default value.
  mutating func clearPrompt() {_uniqueStorage()._prompt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Parameters that affect the behavior of the guidance, typically used for CLIP.
/// The omission of this field implies the default guidance of CFG.
struct Stabilityai_Platformapis_Generation_V1_GuidanceParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// base preset for guidance
  var guidancePreset: Stabilityai_Platformapis_Generation_V1_GuidancePreset = .none

  /// guidance instances
  var instances: [Stabilityai_Platformapis_Generation_V1_GuidanceInstanceParameters] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stabilityai_Platformapis_Generation_V1_TransformType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Stabilityai_Platformapis_Generation_V1_TransformType.OneOf_Type? = nil

  var diffusion: Stabilityai_Platformapis_Generation_V1_DiffusionSampler {
    get {
      if case .diffusion(let v)? = type {return v}
      return .samplerDdim
    }
    set {type = .diffusion(newValue)}
  }

  var upscaler: Stabilityai_Platformapis_Generation_V1_Upscaler {
    get {
      if case .upscaler(let v)? = type {return v}
      return .rgb
    }
    set {type = .upscaler(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case diffusion(Stabilityai_Platformapis_Generation_V1_DiffusionSampler)
    case upscaler(Stabilityai_Platformapis_Generation_V1_Upscaler)

  #if !swift(>=4.1)
    static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformType.OneOf_Type, rhs: Stabilityai_Platformapis_Generation_V1_TransformType.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.diffusion, .diffusion): return {
        guard case .diffusion(let l) = lhs, case .diffusion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upscaler, .upscaler): return {
        guard case .upscaler(let l) = lhs, case .upscaler(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Stabilityai_Platformapis_Generation_V1_ImageParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: UInt64 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var width: UInt64 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var seed: [UInt32] = []

  var samples: UInt64 {
    get {return _samples ?? 0}
    set {_samples = newValue}
  }
  /// Returns true if `samples` has been explicitly set.
  var hasSamples: Bool {return self._samples != nil}
  /// Clears the value of `samples`. Subsequent reads from it will return its default value.
  mutating func clearSamples() {self._samples = nil}

  var steps: UInt64 {
    get {return _steps ?? 0}
    set {_steps = newValue}
  }
  /// Returns true if `steps` has been explicitly set.
  var hasSteps: Bool {return self._steps != nil}
  /// Clears the value of `steps`. Subsequent reads from it will return its default value.
  mutating func clearSteps() {self._steps = nil}

  var transform: Stabilityai_Platformapis_Generation_V1_TransformType {
    get {return _transform ?? Stabilityai_Platformapis_Generation_V1_TransformType()}
    set {_transform = newValue}
  }
  /// Returns true if `transform` has been explicitly set.
  var hasTransform: Bool {return self._transform != nil}
  /// Clears the value of `transform`. Subsequent reads from it will return its default value.
  mutating func clearTransform() {self._transform = nil}

  var parameters: [Stabilityai_Platformapis_Generation_V1_StepParameter] = []

  /// defaults to MASKED_AREA_INIT_ZERO
  var maskedAreaInit: Stabilityai_Platformapis_Generation_V1_MaskedAreaInit {
    get {return _maskedAreaInit ?? .zero}
    set {_maskedAreaInit = newValue}
  }
  /// Returns true if `maskedAreaInit` has been explicitly set.
  var hasMaskedAreaInit: Bool {return self._maskedAreaInit != nil}
  /// Clears the value of `maskedAreaInit`. Subsequent reads from it will return its default value.
  mutating func clearMaskedAreaInit() {self._maskedAreaInit = nil}

  ///defaults to TEXT_ENCODER
  var weightMethod: Stabilityai_Platformapis_Generation_V1_WeightMethod {
    get {return _weightMethod ?? .textEncoder}
    set {_weightMethod = newValue}
  }
  /// Returns true if `weightMethod` has been explicitly set.
  var hasWeightMethod: Bool {return self._weightMethod != nil}
  /// Clears the value of `weightMethod`. Subsequent reads from it will return its default value.
  mutating func clearWeightMethod() {self._weightMethod = nil}

  ///defaults to true
  var quantize: Bool {
    get {return _quantize ?? false}
    set {_quantize = newValue}
  }
  /// Returns true if `quantize` has been explicitly set.
  var hasQuantize: Bool {return self._quantize != nil}
  /// Clears the value of `quantize`. Subsequent reads from it will return its default value.
  mutating func clearQuantize() {self._quantize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _height: UInt64? = nil
  fileprivate var _width: UInt64? = nil
  fileprivate var _samples: UInt64? = nil
  fileprivate var _steps: UInt64? = nil
  fileprivate var _transform: Stabilityai_Platformapis_Generation_V1_TransformType? = nil
  fileprivate var _maskedAreaInit: Stabilityai_Platformapis_Generation_V1_MaskedAreaInit? = nil
  fileprivate var _weightMethod: Stabilityai_Platformapis_Generation_V1_WeightMethod? = nil
  fileprivate var _quantize: Bool? = nil
}

struct Stabilityai_Platformapis_Generation_V1_ClassifierConcept {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var concept: String = String()

  var threshold: Float {
    get {return _threshold ?? 0}
    set {_threshold = newValue}
  }
  /// Returns true if `threshold` has been explicitly set.
  var hasThreshold: Bool {return self._threshold != nil}
  /// Clears the value of `threshold`. Subsequent reads from it will return its default value.
  mutating func clearThreshold() {self._threshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _threshold: Float? = nil
}

struct Stabilityai_Platformapis_Generation_V1_ClassifierCategory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var concepts: [Stabilityai_Platformapis_Generation_V1_ClassifierConcept] = []

  var adjustment: Float {
    get {return _adjustment ?? 0}
    set {_adjustment = newValue}
  }
  /// Returns true if `adjustment` has been explicitly set.
  var hasAdjustment: Bool {return self._adjustment != nil}
  /// Clears the value of `adjustment`. Subsequent reads from it will return its default value.
  mutating func clearAdjustment() {self._adjustment = nil}

  var action: Stabilityai_Platformapis_Generation_V1_Action {
    get {return _action ?? .passthrough}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var classifierMode: Stabilityai_Platformapis_Generation_V1_ClassifierMode {
    get {return _classifierMode ?? .clsfrModeZeroshot}
    set {_classifierMode = newValue}
  }
  /// Returns true if `classifierMode` has been explicitly set.
  var hasClassifierMode: Bool {return self._classifierMode != nil}
  /// Clears the value of `classifierMode`. Subsequent reads from it will return its default value.
  mutating func clearClassifierMode() {self._classifierMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _adjustment: Float? = nil
  fileprivate var _action: Stabilityai_Platformapis_Generation_V1_Action? = nil
  fileprivate var _classifierMode: Stabilityai_Platformapis_Generation_V1_ClassifierMode? = nil
}

struct Stabilityai_Platformapis_Generation_V1_ClassifierParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var categories: [Stabilityai_Platformapis_Generation_V1_ClassifierCategory] = []

  var exceeds: [Stabilityai_Platformapis_Generation_V1_ClassifierCategory] = []

  var realizedAction: Stabilityai_Platformapis_Generation_V1_Action {
    get {return _realizedAction ?? .passthrough}
    set {_realizedAction = newValue}
  }
  /// Returns true if `realizedAction` has been explicitly set.
  var hasRealizedAction: Bool {return self._realizedAction != nil}
  /// Clears the value of `realizedAction`. Subsequent reads from it will return its default value.
  mutating func clearRealizedAction() {self._realizedAction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _realizedAction: Stabilityai_Platformapis_Generation_V1_Action? = nil
}

/// Interpolation between two images applied at specified blend ratios
struct Stabilityai_Platformapis_Generation_V1_InterpolateParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ratios: [Float] = []

  var mode: Stabilityai_Platformapis_Generation_V1_InterpolateMode {
    get {return _mode ?? .interpolateLinear}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mode: Stabilityai_Platformapis_Generation_V1_InterpolateMode? = nil
}

struct Stabilityai_Platformapis_Generation_V1_TransformColorAdjust {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scale pixel intensities, 1.0 is no change
  var brightness: Float {
    get {return _storage._brightness ?? 0}
    set {_uniqueStorage()._brightness = newValue}
  }
  /// Returns true if `brightness` has been explicitly set.
  var hasBrightness: Bool {return _storage._brightness != nil}
  /// Clears the value of `brightness`. Subsequent reads from it will return its default value.
  mutating func clearBrightness() {_uniqueStorage()._brightness = nil}

  /// contrast adjustment, 1.0 is no change
  var contrast: Float {
    get {return _storage._contrast ?? 0}
    set {_uniqueStorage()._contrast = newValue}
  }
  /// Returns true if `contrast` has been explicitly set.
  var hasContrast: Bool {return _storage._contrast != nil}
  /// Clears the value of `contrast`. Subsequent reads from it will return its default value.
  mutating func clearContrast() {_uniqueStorage()._contrast = nil}

  /// -180 to 180 hue adjustment, 0.0 is no change
  var hue: Float {
    get {return _storage._hue ?? 0}
    set {_uniqueStorage()._hue = newValue}
  }
  /// Returns true if `hue` has been explicitly set.
  var hasHue: Bool {return _storage._hue != nil}
  /// Clears the value of `hue`. Subsequent reads from it will return its default value.
  mutating func clearHue() {_uniqueStorage()._hue = nil}

  /// 0.0 to 2.0 saturation scale, 1.0 is no change
  var saturation: Float {
    get {return _storage._saturation ?? 0}
    set {_uniqueStorage()._saturation = newValue}
  }
  /// Returns true if `saturation` has been explicitly set.
  var hasSaturation: Bool {return _storage._saturation != nil}
  /// Clears the value of `saturation`. Subsequent reads from it will return its default value.
  mutating func clearSaturation() {_uniqueStorage()._saturation = nil}

  /// -1.0 to 1.0 lightness adjustment, 0.0 is no change
  var lightness: Float {
    get {return _storage._lightness ?? 0}
    set {_uniqueStorage()._lightness = newValue}
  }
  /// Returns true if `lightness` has been explicitly set.
  var hasLightness: Bool {return _storage._lightness != nil}
  /// Clears the value of `lightness`. Subsequent reads from it will return its default value.
  mutating func clearLightness() {_uniqueStorage()._lightness = nil}

  /// image to color match
  var matchImage: Stabilityai_Platformapis_Generation_V1_Artifact {
    get {return _storage._matchImage ?? Stabilityai_Platformapis_Generation_V1_Artifact()}
    set {_uniqueStorage()._matchImage = newValue}
  }
  /// Returns true if `matchImage` has been explicitly set.
  var hasMatchImage: Bool {return _storage._matchImage != nil}
  /// Clears the value of `matchImage`. Subsequent reads from it will return its default value.
  mutating func clearMatchImage() {_uniqueStorage()._matchImage = nil}

  /// color match mode to use
  var matchMode: Stabilityai_Platformapis_Generation_V1_ColorMatchMode {
    get {return _storage._matchMode ?? .colorMatchHsv}
    set {_uniqueStorage()._matchMode = newValue}
  }
  /// Returns true if `matchMode` has been explicitly set.
  var hasMatchMode: Bool {return _storage._matchMode != nil}
  /// Clears the value of `matchMode`. Subsequent reads from it will return its default value.
  mutating func clearMatchMode() {_uniqueStorage()._matchMode = nil}

  /// amount of gaussian noise to add
  var noiseAmount: Float {
    get {return _storage._noiseAmount ?? 0}
    set {_uniqueStorage()._noiseAmount = newValue}
  }
  /// Returns true if `noiseAmount` has been explicitly set.
  var hasNoiseAmount: Bool {return _storage._noiseAmount != nil}
  /// Clears the value of `noiseAmount`. Subsequent reads from it will return its default value.
  mutating func clearNoiseAmount() {_uniqueStorage()._noiseAmount = nil}

  /// random seed for noise
  var noiseSeed: UInt32 {
    get {return _storage._noiseSeed ?? 0}
    set {_uniqueStorage()._noiseSeed = newValue}
  }
  /// Returns true if `noiseSeed` has been explicitly set.
  var hasNoiseSeed: Bool {return _storage._noiseSeed != nil}
  /// Clears the value of `noiseSeed`. Subsequent reads from it will return its default value.
  mutating func clearNoiseSeed() {_uniqueStorage()._noiseSeed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stabilityai_Platformapis_Generation_V1_TransformDepthCalc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// blend factor between AdaBins (0.0) and MiDaS (1.0)
  var blendWeight: Float {
    get {return _blendWeight ?? 0}
    set {_blendWeight = newValue}
  }
  /// Returns true if `blendWeight` has been explicitly set.
  var hasBlendWeight: Bool {return self._blendWeight != nil}
  /// Clears the value of `blendWeight`. Subsequent reads from it will return its default value.
  mutating func clearBlendWeight() {self._blendWeight = nil}

  /// defaults to 0.0
  var blurRadius: UInt32 {
    get {return _blurRadius ?? 0}
    set {_blurRadius = newValue}
  }
  /// Returns true if `blurRadius` has been explicitly set.
  var hasBlurRadius: Bool {return self._blurRadius != nil}
  /// Clears the value of `blurRadius`. Subsequent reads from it will return its default value.
  mutating func clearBlurRadius() {self._blurRadius = nil}

  /// make near depths have higher values
  var reverse: Bool {
    get {return _reverse ?? false}
    set {_reverse = newValue}
  }
  /// Returns true if `reverse` has been explicitly set.
  var hasReverse: Bool {return self._reverse != nil}
  /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
  mutating func clearReverse() {self._reverse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blendWeight: Float? = nil
  fileprivate var _blurRadius: UInt32? = nil
  fileprivate var _reverse: Bool? = nil
}

struct Stabilityai_Platformapis_Generation_V1_TransformMatrix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Column-major 3x3 or 4x4 perspective matrix
  /// [sx, 10, 20, tx]   [x]
  /// [01, sy, 21, ty] . [y]
  /// [02, 12, sz, tz]   [z]
  /// [03, 13, 23, 33]   [1]
  var data: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stabilityai_Platformapis_Generation_V1_TransformResample {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// extrapolation of border pixels
  var borderMode: Stabilityai_Platformapis_Generation_V1_BorderMode = .borderReflect

  /// 3x3 or 4x4 matrix
  var transform: Stabilityai_Platformapis_Generation_V1_TransformMatrix {
    get {return _transform ?? Stabilityai_Platformapis_Generation_V1_TransformMatrix()}
    set {_transform = newValue}
  }
  /// Returns true if `transform` has been explicitly set.
  var hasTransform: Bool {return self._transform != nil}
  /// Clears the value of `transform`. Subsequent reads from it will return its default value.
  mutating func clearTransform() {self._transform = nil}

  /// 3x3 or 4x4 matrix, defaults to identity
  var prevTransform: Stabilityai_Platformapis_Generation_V1_TransformMatrix {
    get {return _prevTransform ?? Stabilityai_Platformapis_Generation_V1_TransformMatrix()}
    set {_prevTransform = newValue}
  }
  /// Returns true if `prevTransform` has been explicitly set.
  var hasPrevTransform: Bool {return self._prevTransform != nil}
  /// Clears the value of `prevTransform`. Subsequent reads from it will return its default value.
  mutating func clearPrevTransform() {self._prevTransform = nil}

  /// depth warp factor, defaults to 1.0
  var depthWarp: Float {
    get {return _depthWarp ?? 0}
    set {_depthWarp = newValue}
  }
  /// Returns true if `depthWarp` has been explicitly set.
  var hasDepthWarp: Bool {return self._depthWarp != nil}
  /// Clears the value of `depthWarp`. Subsequent reads from it will return its default value.
  mutating func clearDepthWarp() {self._depthWarp = nil}

  /// return inpaint mask
  var exportMask: Bool {
    get {return _exportMask ?? false}
    set {_exportMask = newValue}
  }
  /// Returns true if `exportMask` has been explicitly set.
  var hasExportMask: Bool {return self._exportMask != nil}
  /// Clears the value of `exportMask`. Subsequent reads from it will return its default value.
  mutating func clearExportMask() {self._exportMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transform: Stabilityai_Platformapis_Generation_V1_TransformMatrix? = nil
  fileprivate var _prevTransform: Stabilityai_Platformapis_Generation_V1_TransformMatrix? = nil
  fileprivate var _depthWarp: Float? = nil
  fileprivate var _exportMask: Bool? = nil
}

struct Stabilityai_Platformapis_Generation_V1_CameraParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cameraType: Stabilityai_Platformapis_Generation_V1_CameraType = .cameraPerspective

  /// Nearest plane depth of a rendered frustum
  var nearPlane: Float = 0

  /// Farthest plane depth of a rendered frustum
  var farPlane: Float = 0

  /// Camera field of view (in degrees). Must be set for CAMERA_PERSPECTIVE type.
  var fov: Float {
    get {return _fov ?? 0}
    set {_fov = newValue}
  }
  /// Returns true if `fov` has been explicitly set.
  var hasFov: Bool {return self._fov != nil}
  /// Clears the value of `fov`. Subsequent reads from it will return its default value.
  mutating func clearFov() {self._fov = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fov: Float? = nil
}

struct Stabilityai_Platformapis_Generation_V1_TransformCameraPose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 4x4 transform matrix for the next frame
  var worldToViewMatrix: Stabilityai_Platformapis_Generation_V1_TransformMatrix {
    get {return _worldToViewMatrix ?? Stabilityai_Platformapis_Generation_V1_TransformMatrix()}
    set {_worldToViewMatrix = newValue}
  }
  /// Returns true if `worldToViewMatrix` has been explicitly set.
  var hasWorldToViewMatrix: Bool {return self._worldToViewMatrix != nil}
  /// Clears the value of `worldToViewMatrix`. Subsequent reads from it will return its default value.
  mutating func clearWorldToViewMatrix() {self._worldToViewMatrix = nil}

  var cameraParameters: Stabilityai_Platformapis_Generation_V1_CameraParameters {
    get {return _cameraParameters ?? Stabilityai_Platformapis_Generation_V1_CameraParameters()}
    set {_cameraParameters = newValue}
  }
  /// Returns true if `cameraParameters` has been explicitly set.
  var hasCameraParameters: Bool {return self._cameraParameters != nil}
  /// Clears the value of `cameraParameters`. Subsequent reads from it will return its default value.
  mutating func clearCameraParameters() {self._cameraParameters = nil}

  /// Prefill masked areas with values matching the colors around the area
  var doPrefill: Bool = false

  /// Both image and mask will be rendered using this method.
  var renderMode: Stabilityai_Platformapis_Generation_V1_RenderMode = .renderMesh

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _worldToViewMatrix: Stabilityai_Platformapis_Generation_V1_TransformMatrix? = nil
  fileprivate var _cameraParameters: Stabilityai_Platformapis_Generation_V1_CameraParameters? = nil
}

struct Stabilityai_Platformapis_Generation_V1_TransformParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transform: Stabilityai_Platformapis_Generation_V1_TransformParameters.OneOf_Transform? = nil

  var colorAdjust: Stabilityai_Platformapis_Generation_V1_TransformColorAdjust {
    get {
      if case .colorAdjust(let v)? = transform {return v}
      return Stabilityai_Platformapis_Generation_V1_TransformColorAdjust()
    }
    set {transform = .colorAdjust(newValue)}
  }

  var depthCalc: Stabilityai_Platformapis_Generation_V1_TransformDepthCalc {
    get {
      if case .depthCalc(let v)? = transform {return v}
      return Stabilityai_Platformapis_Generation_V1_TransformDepthCalc()
    }
    set {transform = .depthCalc(newValue)}
  }

  var resample: Stabilityai_Platformapis_Generation_V1_TransformResample {
    get {
      if case .resample(let v)? = transform {return v}
      return Stabilityai_Platformapis_Generation_V1_TransformResample()
    }
    set {transform = .resample(newValue)}
  }

  var cameraPose: Stabilityai_Platformapis_Generation_V1_TransformCameraPose {
    get {
      if case .cameraPose(let v)? = transform {return v}
      return Stabilityai_Platformapis_Generation_V1_TransformCameraPose()
    }
    set {transform = .cameraPose(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Transform: Equatable {
    case colorAdjust(Stabilityai_Platformapis_Generation_V1_TransformColorAdjust)
    case depthCalc(Stabilityai_Platformapis_Generation_V1_TransformDepthCalc)
    case resample(Stabilityai_Platformapis_Generation_V1_TransformResample)
    case cameraPose(Stabilityai_Platformapis_Generation_V1_TransformCameraPose)

  #if !swift(>=4.1)
    static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformParameters.OneOf_Transform, rhs: Stabilityai_Platformapis_Generation_V1_TransformParameters.OneOf_Transform) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.colorAdjust, .colorAdjust): return {
        guard case .colorAdjust(let l) = lhs, case .colorAdjust(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.depthCalc, .depthCalc): return {
        guard case .depthCalc(let l) = lhs, case .depthCalc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resample, .resample): return {
        guard case .resample(let l) = lhs, case .resample(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cameraPose, .cameraPose): return {
        guard case .cameraPose(let l) = lhs, case .cameraPose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Stabilityai_Platformapis_Generation_V1_AssetParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: Stabilityai_Platformapis_Generation_V1_AssetAction = .assetPut

  var projectID: String = String()

  var use: Stabilityai_Platformapis_Generation_V1_AssetUse = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AnswerMeta is a set of metadata about an answer, usually the operating
/// environment.
struct Stabilityai_Platformapis_Generation_V1_AnswerMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gpuID: String {
    get {return _gpuID ?? String()}
    set {_gpuID = newValue}
  }
  /// Returns true if `gpuID` has been explicitly set.
  var hasGpuID: Bool {return self._gpuID != nil}
  /// Clears the value of `gpuID`. Subsequent reads from it will return its default value.
  mutating func clearGpuID() {self._gpuID = nil}

  var cpuID: String {
    get {return _cpuID ?? String()}
    set {_cpuID = newValue}
  }
  /// Returns true if `cpuID` has been explicitly set.
  var hasCpuID: Bool {return self._cpuID != nil}
  /// Clears the value of `cpuID`. Subsequent reads from it will return its default value.
  mutating func clearCpuID() {self._cpuID = nil}

  var nodeID: String {
    get {return _nodeID ?? String()}
    set {_nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  var hasNodeID: Bool {return self._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  mutating func clearNodeID() {self._nodeID = nil}

  var engineID: String {
    get {return _engineID ?? String()}
    set {_engineID = newValue}
  }
  /// Returns true if `engineID` has been explicitly set.
  var hasEngineID: Bool {return self._engineID != nil}
  /// Clears the value of `engineID`. Subsequent reads from it will return its default value.
  mutating func clearEngineID() {self._engineID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gpuID: String? = nil
  fileprivate var _cpuID: String? = nil
  fileprivate var _nodeID: String? = nil
  fileprivate var _engineID: String? = nil
}

/// An Answer is a response to a Request. It is a set of Artifacts, which can be
/// of any type and forwarded to the client or the next stage.
struct Stabilityai_Platformapis_Generation_V1_Answer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var answerID: String = String()

  var requestID: String = String()

  var received: UInt64 = 0

  var created: UInt64 = 0

  var meta: Stabilityai_Platformapis_Generation_V1_AnswerMeta {
    get {return _meta ?? Stabilityai_Platformapis_Generation_V1_AnswerMeta()}
    set {_meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  var hasMeta: Bool {return self._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  mutating func clearMeta() {self._meta = nil}

  var artifacts: [Stabilityai_Platformapis_Generation_V1_Artifact] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _meta: Stabilityai_Platformapis_Generation_V1_AnswerMeta? = nil
}

/// An AnswerBatch is a set of Answers. It can represent one or several completed
/// requests, which may be sent to the client in a single response.
struct Stabilityai_Platformapis_Generation_V1_AnswerBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var batchID: String = String()

  var answers: [Stabilityai_Platformapis_Generation_V1_Answer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Request is a set of Artifacts, which can be of any type with model or
/// transform parameters. It is sent to the server, which will respond with an
/// Answer.
struct Stabilityai_Platformapis_Generation_V1_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var engineID: String {
    get {return _storage._engineID}
    set {_uniqueStorage()._engineID = newValue}
  }

  var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  var requestedType: Stabilityai_Platformapis_Generation_V1_ArtifactType {
    get {return _storage._requestedType}
    set {_uniqueStorage()._requestedType = newValue}
  }

  var prompt: [Stabilityai_Platformapis_Generation_V1_Prompt] {
    get {return _storage._prompt}
    set {_uniqueStorage()._prompt = newValue}
  }

  var params: OneOf_Params? {
    get {return _storage._params}
    set {_uniqueStorage()._params = newValue}
  }

  var image: Stabilityai_Platformapis_Generation_V1_ImageParameters {
    get {
      if case .image(let v)? = _storage._params {return v}
      return Stabilityai_Platformapis_Generation_V1_ImageParameters()
    }
    set {_uniqueStorage()._params = .image(newValue)}
  }

  var classifier: Stabilityai_Platformapis_Generation_V1_ClassifierParameters {
    get {
      if case .classifier(let v)? = _storage._params {return v}
      return Stabilityai_Platformapis_Generation_V1_ClassifierParameters()
    }
    set {_uniqueStorage()._params = .classifier(newValue)}
  }

  var asset: Stabilityai_Platformapis_Generation_V1_AssetParameters {
    get {
      if case .asset(let v)? = _storage._params {return v}
      return Stabilityai_Platformapis_Generation_V1_AssetParameters()
    }
    set {_uniqueStorage()._params = .asset(newValue)}
  }

  var interpolate: Stabilityai_Platformapis_Generation_V1_InterpolateParameters {
    get {
      if case .interpolate(let v)? = _storage._params {return v}
      return Stabilityai_Platformapis_Generation_V1_InterpolateParameters()
    }
    set {_uniqueStorage()._params = .interpolate(newValue)}
  }

  var transform: Stabilityai_Platformapis_Generation_V1_TransformParameters {
    get {
      if case .transform(let v)? = _storage._params {return v}
      return Stabilityai_Platformapis_Generation_V1_TransformParameters()
    }
    set {_uniqueStorage()._params = .transform(newValue)}
  }

  var conditioner: Stabilityai_Platformapis_Generation_V1_ConditionerParameters {
    get {return _storage._conditioner ?? Stabilityai_Platformapis_Generation_V1_ConditionerParameters()}
    set {_uniqueStorage()._conditioner = newValue}
  }
  /// Returns true if `conditioner` has been explicitly set.
  var hasConditioner: Bool {return _storage._conditioner != nil}
  /// Clears the value of `conditioner`. Subsequent reads from it will return its default value.
  mutating func clearConditioner() {_uniqueStorage()._conditioner = nil}

  /// for development use
  var extras: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._extras ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._extras = newValue}
  }
  /// Returns true if `extras` has been explicitly set.
  var hasExtras: Bool {return _storage._extras != nil}
  /// Clears the value of `extras`. Subsequent reads from it will return its default value.
  mutating func clearExtras() {_uniqueStorage()._extras = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case image(Stabilityai_Platformapis_Generation_V1_ImageParameters)
    case classifier(Stabilityai_Platformapis_Generation_V1_ClassifierParameters)
    case asset(Stabilityai_Platformapis_Generation_V1_AssetParameters)
    case interpolate(Stabilityai_Platformapis_Generation_V1_InterpolateParameters)
    case transform(Stabilityai_Platformapis_Generation_V1_TransformParameters)

  #if !swift(>=4.1)
    static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Request.OneOf_Params, rhs: Stabilityai_Platformapis_Generation_V1_Request.OneOf_Params) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.classifier, .classifier): return {
        guard case .classifier(let l) = lhs, case .classifier(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.asset, .asset): return {
        guard case .asset(let l) = lhs, case .asset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.interpolate, .interpolate): return {
        guard case .interpolate(let l) = lhs, case .interpolate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transform, .transform): return {
        guard case .transform(let l) = lhs, case .transform(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stabilityai_Platformapis_Generation_V1_OnStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: [Stabilityai_Platformapis_Generation_V1_FinishReason] = []

  var target: String {
    get {return _target ?? String()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  var action: [Stabilityai_Platformapis_Generation_V1_StageAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _target: String? = nil
}

struct Stabilityai_Platformapis_Generation_V1_Stage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var request: Stabilityai_Platformapis_Generation_V1_Request {
    get {return _request ?? Stabilityai_Platformapis_Generation_V1_Request()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var onStatus: [Stabilityai_Platformapis_Generation_V1_OnStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Stabilityai_Platformapis_Generation_V1_Request? = nil
}

struct Stabilityai_Platformapis_Generation_V1_ChainRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var stage: [Stabilityai_Platformapis_Generation_V1_Stage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stabilityai_Platformapis_Generation_V1_FinishReason: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ArtifactType: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_MaskedAreaInit: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_WeightMethod: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_DiffusionSampler: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Upscaler: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_GuidancePreset: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ModelArchitecture: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Action: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ClassifierMode: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_InterpolateMode: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_BorderMode: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ColorMatchMode: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_CameraType: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_RenderMode: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_AssetAction: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_AssetUse: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_StageAction: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Token: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Tokens: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Artifact: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Artifact.OneOf_Data: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_PromptParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Prompt: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Prompt.OneOf_Prompt: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_SamplerParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ConditionerParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ScheduleParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_StepParameter: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Model: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_CutoutParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_GuidanceScheduleParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_GuidanceInstanceParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_GuidanceParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformType: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformType.OneOf_Type: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ImageParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ClassifierConcept: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ClassifierCategory: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ClassifierParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_InterpolateParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformColorAdjust: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformDepthCalc: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformMatrix: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformResample: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_CameraParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformCameraPose: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_TransformParameters.OneOf_Transform: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_AssetParameters: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_AnswerMeta: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Answer: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_AnswerBatch: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Request: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Request.OneOf_Params: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_OnStatus: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_Stage: @unchecked Sendable {}
extension Stabilityai_Platformapis_Generation_V1_ChainRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stabilityai.platformapis.generation.v1"

extension Stabilityai_Platformapis_Generation_V1_FinishReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "LENGTH"),
    2: .same(proto: "STOP"),
    3: .same(proto: "ERROR"),
    4: .same(proto: "FILTER"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_ArtifactType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ARTIFACT_NONE"),
    1: .same(proto: "ARTIFACT_IMAGE"),
    2: .same(proto: "ARTIFACT_VIDEO"),
    3: .same(proto: "ARTIFACT_TEXT"),
    4: .same(proto: "ARTIFACT_TOKENS"),
    5: .same(proto: "ARTIFACT_EMBEDDING"),
    6: .same(proto: "ARTIFACT_CLASSIFICATIONS"),
    7: .same(proto: "ARTIFACT_MASK"),
    8: .same(proto: "ARTIFACT_LATENT"),
    9: .same(proto: "ARTIFACT_TENSOR"),
    10: .same(proto: "ARTIFACT_DEPTH"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_MaskedAreaInit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MASKED_AREA_INIT_ZERO"),
    1: .same(proto: "MASKED_AREA_INIT_RANDOM"),
    2: .same(proto: "MASKED_AREA_INIT_ORIGINAL"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_WeightMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_ENCODER"),
    1: .same(proto: "CROSS_ATTENTION"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_DiffusionSampler: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SAMPLER_DDIM"),
    1: .same(proto: "SAMPLER_DDPM"),
    2: .same(proto: "SAMPLER_K_EULER"),
    3: .same(proto: "SAMPLER_K_EULER_ANCESTRAL"),
    4: .same(proto: "SAMPLER_K_HEUN"),
    5: .same(proto: "SAMPLER_K_DPM_2"),
    6: .same(proto: "SAMPLER_K_DPM_2_ANCESTRAL"),
    7: .same(proto: "SAMPLER_K_LMS"),
    8: .same(proto: "SAMPLER_K_DPMPP_2S_ANCESTRAL"),
    9: .same(proto: "SAMPLER_K_DPMPP_2M"),
    10: .same(proto: "SAMPLER_K_DPMPP_SDE"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_Upscaler: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPSCALER_RGB"),
    1: .same(proto: "UPSCALER_GFPGAN"),
    2: .same(proto: "UPSCALER_ESRGAN"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_GuidancePreset: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GUIDANCE_PRESET_NONE"),
    1: .same(proto: "GUIDANCE_PRESET_SIMPLE"),
    2: .same(proto: "GUIDANCE_PRESET_FAST_BLUE"),
    3: .same(proto: "GUIDANCE_PRESET_FAST_GREEN"),
    4: .same(proto: "GUIDANCE_PRESET_SLOW"),
    5: .same(proto: "GUIDANCE_PRESET_SLOWER"),
    6: .same(proto: "GUIDANCE_PRESET_SLOWEST"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_ModelArchitecture: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODEL_ARCHITECTURE_NONE"),
    1: .same(proto: "MODEL_ARCHITECTURE_CLIP_VIT"),
    2: .same(proto: "MODEL_ARCHITECTURE_CLIP_RESNET"),
    3: .same(proto: "MODEL_ARCHITECTURE_LDM"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTION_PASSTHROUGH"),
    1: .same(proto: "ACTION_REGENERATE_DUPLICATE"),
    2: .same(proto: "ACTION_REGENERATE"),
    3: .same(proto: "ACTION_OBFUSCATE_DUPLICATE"),
    4: .same(proto: "ACTION_OBFUSCATE"),
    5: .same(proto: "ACTION_DISCARD"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_ClassifierMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLSFR_MODE_ZEROSHOT"),
    1: .same(proto: "CLSFR_MODE_MULTICLASS"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_InterpolateMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERPOLATE_LINEAR"),
    1: .same(proto: "INTERPOLATE_RIFE"),
    2: .same(proto: "INTERPOLATE_VAE_LINEAR"),
    3: .same(proto: "INTERPOLATE_VAE_SLERP"),
    4: .same(proto: "INTERPOLATE_FILM"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_BorderMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BORDER_REFLECT"),
    1: .same(proto: "BORDER_REPLICATE"),
    2: .same(proto: "BORDER_WRAP"),
    3: .same(proto: "BORDER_ZERO"),
    4: .same(proto: "BORDER_PREFILL"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_ColorMatchMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COLOR_MATCH_HSV"),
    1: .same(proto: "COLOR_MATCH_LAB"),
    2: .same(proto: "COLOR_MATCH_RGB"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_CameraType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAMERA_PERSPECTIVE"),
    1: .same(proto: "CAMERA_ORTHOGRAPHIC"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_RenderMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RENDER_MESH"),
    1: .same(proto: "RENDER_POINTCLOUD"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_AssetAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASSET_PUT"),
    1: .same(proto: "ASSET_GET"),
    2: .same(proto: "ASSET_DELETE"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_AssetUse: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASSET_USE_UNDEFINED"),
    1: .same(proto: "ASSET_USE_INPUT"),
    2: .same(proto: "ASSET_USE_OUTPUT"),
    3: .same(proto: "ASSET_USE_INTERMEDIATE"),
    4: .same(proto: "ASSET_USE_PROJECT"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_StageAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STAGE_ACTION_PASS"),
    1: .same(proto: "STAGE_ACTION_DISCARD"),
    2: .same(proto: "STAGE_ACTION_RETURN"),
  ]
}

extension Stabilityai_Platformapis_Generation_V1_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Token, rhs: Stabilityai_Platformapis_Generation_V1_Token) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_Tokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tokens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokens"),
    2: .standard(proto: "tokenizer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._tokenizerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 1)
    }
    try { if let v = self._tokenizerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Tokens, rhs: Stabilityai_Platformapis_Generation_V1_Tokens) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs._tokenizerID != rhs._tokenizerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_Artifact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Artifact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "mime"),
    4: .same(proto: "magic"),
    5: .same(proto: "binary"),
    6: .same(proto: "text"),
    7: .same(proto: "tokens"),
    11: .same(proto: "classifier"),
    14: .same(proto: "tensor"),
    8: .same(proto: "index"),
    9: .standard(proto: "finish_reason"),
    10: .same(proto: "seed"),
    12: .same(proto: "uuid"),
    13: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._magic) }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .binary(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .text(v)
        }
      }()
      case 7: try {
        var v: Stabilityai_Platformapis_Generation_V1_Tokens?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .tokens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .tokens(v)
        }
      }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.finishReason) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.seed) }()
      case 11: try {
        var v: Stabilityai_Platformapis_Generation_V1_ClassifierParameters?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .classifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .classifier(v)
        }
      }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 14: try {
        var v: Tensors_Tensor?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .tensor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .tensor(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.type != .artifactNone {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.mime.isEmpty {
      try visitor.visitSingularStringField(value: self.mime, fieldNumber: 3)
    }
    try { if let v = self._magic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    switch self.data {
    case .binary?: try {
      guard case .binary(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case .text?: try {
      guard case .text(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .tokens?: try {
      guard case .tokens(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 8)
    }
    if self.finishReason != .null {
      try visitor.visitSingularEnumField(value: self.finishReason, fieldNumber: 9)
    }
    if self.seed != 0 {
      try visitor.visitSingularUInt32Field(value: self.seed, fieldNumber: 10)
    }
    try { if case .classifier(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 12)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 13)
    }
    try { if case .tensor(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Artifact, rhs: Stabilityai_Platformapis_Generation_V1_Artifact) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.mime != rhs.mime {return false}
    if lhs._magic != rhs._magic {return false}
    if lhs.data != rhs.data {return false}
    if lhs.index != rhs.index {return false}
    if lhs.finishReason != rhs.finishReason {return false}
    if lhs.seed != rhs.seed {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_PromptParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromptParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "weight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._init_p) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._weight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._init_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._weight {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_PromptParameters, rhs: Stabilityai_Platformapis_Generation_V1_PromptParameters) -> Bool {
    if lhs._init_p != rhs._init_p {return false}
    if lhs._weight != rhs._weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_Prompt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Prompt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .same(proto: "text"),
    3: .same(proto: "tokens"),
    4: .same(proto: "artifact"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.prompt != nil {try decoder.handleConflictingOneOf()}
          self.prompt = .text(v)
        }
      }()
      case 3: try {
        var v: Stabilityai_Platformapis_Generation_V1_Tokens?
        var hadOneofValue = false
        if let current = self.prompt {
          hadOneofValue = true
          if case .tokens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.prompt = .tokens(v)
        }
      }()
      case 4: try {
        var v: Stabilityai_Platformapis_Generation_V1_Artifact?
        var hadOneofValue = false
        if let current = self.prompt {
          hadOneofValue = true
          if case .artifact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.prompt = .artifact(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.prompt {
    case .text?: try {
      guard case .text(let v)? = self.prompt else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .tokens?: try {
      guard case .tokens(let v)? = self.prompt else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .artifact?: try {
      guard case .artifact(let v)? = self.prompt else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Prompt, rhs: Stabilityai_Platformapis_Generation_V1_Prompt) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_SamplerParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SamplerParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eta"),
    2: .standard(proto: "sampling_steps"),
    3: .standard(proto: "latent_channels"),
    4: .standard(proto: "downsampling_factor"),
    5: .standard(proto: "cfg_scale"),
    6: .standard(proto: "init_noise_scale"),
    7: .standard(proto: "step_noise_scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._eta) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._samplingSteps) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._latentChannels) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._downsamplingFactor) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._cfgScale) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._initNoiseScale) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._stepNoiseScale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._eta {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._samplingSteps {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._latentChannels {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._downsamplingFactor {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cfgScale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._initNoiseScale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._stepNoiseScale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_SamplerParameters, rhs: Stabilityai_Platformapis_Generation_V1_SamplerParameters) -> Bool {
    if lhs._eta != rhs._eta {return false}
    if lhs._samplingSteps != rhs._samplingSteps {return false}
    if lhs._latentChannels != rhs._latentChannels {return false}
    if lhs._downsamplingFactor != rhs._downsamplingFactor {return false}
    if lhs._cfgScale != rhs._cfgScale {return false}
    if lhs._initNoiseScale != rhs._initNoiseScale {return false}
    if lhs._stepNoiseScale != rhs._stepNoiseScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_ConditionerParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConditionerParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vector_adjust_prior"),
    2: .same(proto: "conditioner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._vectorAdjustPrior) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._conditioner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vectorAdjustPrior {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._conditioner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_ConditionerParameters, rhs: Stabilityai_Platformapis_Generation_V1_ConditionerParameters) -> Bool {
    if lhs._vectorAdjustPrior != rhs._vectorAdjustPrior {return false}
    if lhs._conditioner != rhs._conditioner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_ScheduleParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScheduleParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._end) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_ScheduleParameters, rhs: Stabilityai_Platformapis_Generation_V1_ScheduleParameters) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_StepParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StepParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scaled_step"),
    2: .same(proto: "sampler"),
    3: .same(proto: "schedule"),
    4: .same(proto: "guidance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.scaledStep) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sampler) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._guidance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scaledStep != 0 {
      try visitor.visitSingularFloatField(value: self.scaledStep, fieldNumber: 1)
    }
    try { if let v = self._sampler {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._guidance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_StepParameter, rhs: Stabilityai_Platformapis_Generation_V1_StepParameter) -> Bool {
    if lhs.scaledStep != rhs.scaledStep {return false}
    if lhs._sampler != rhs._sampler {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs._guidance != rhs._guidance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_Model: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Model"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "architecture"),
    2: .same(proto: "publisher"),
    3: .same(proto: "dataset"),
    4: .same(proto: "version"),
    5: .standard(proto: "semantic_version"),
    6: .same(proto: "alias"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.architecture) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publisher) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dataset) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.version) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.semanticVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.architecture != .none {
      try visitor.visitSingularEnumField(value: self.architecture, fieldNumber: 1)
    }
    if !self.publisher.isEmpty {
      try visitor.visitSingularStringField(value: self.publisher, fieldNumber: 2)
    }
    if !self.dataset.isEmpty {
      try visitor.visitSingularStringField(value: self.dataset, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularFloatField(value: self.version, fieldNumber: 4)
    }
    if !self.semanticVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.semanticVersion, fieldNumber: 5)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Model, rhs: Stabilityai_Platformapis_Generation_V1_Model) -> Bool {
    if lhs.architecture != rhs.architecture {return false}
    if lhs.publisher != rhs.publisher {return false}
    if lhs.dataset != rhs.dataset {return false}
    if lhs.version != rhs.version {return false}
    if lhs.semanticVersion != rhs.semanticVersion {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_CutoutParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CutoutParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cutouts"),
    2: .same(proto: "count"),
    3: .same(proto: "gray"),
    4: .same(proto: "blur"),
    5: .standard(proto: "size_power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cutouts) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._gray) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._blur) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._sizePower) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cutouts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cutouts, fieldNumber: 1)
    }
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gray {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._blur {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sizePower {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_CutoutParameters, rhs: Stabilityai_Platformapis_Generation_V1_CutoutParameters) -> Bool {
    if lhs.cutouts != rhs.cutouts {return false}
    if lhs._count != rhs._count {return false}
    if lhs._gray != rhs._gray {return false}
    if lhs._blur != rhs._blur {return false}
    if lhs._sizePower != rhs._sizePower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_GuidanceScheduleParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GuidanceScheduleParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.duration) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.duration != 0 {
      try visitor.visitSingularFloatField(value: self.duration, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_GuidanceScheduleParameters, rhs: Stabilityai_Platformapis_Generation_V1_GuidanceScheduleParameters) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_GuidanceInstanceParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GuidanceInstanceParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "models"),
    3: .standard(proto: "guidance_strength"),
    4: .same(proto: "schedule"),
    5: .same(proto: "cutouts"),
    6: .same(proto: "prompt"),
  ]

  fileprivate class _StorageClass {
    var _models: [Stabilityai_Platformapis_Generation_V1_Model] = []
    var _guidanceStrength: Float? = nil
    var _schedule: [Stabilityai_Platformapis_Generation_V1_GuidanceScheduleParameters] = []
    var _cutouts: Stabilityai_Platformapis_Generation_V1_CutoutParameters? = nil
    var _prompt: Stabilityai_Platformapis_Generation_V1_Prompt? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _models = source._models
      _guidanceStrength = source._guidanceStrength
      _schedule = source._schedule
      _cutouts = source._cutouts
      _prompt = source._prompt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._models) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._guidanceStrength) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._schedule) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._cutouts) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._prompt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._models.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._models, fieldNumber: 2)
      }
      try { if let v = _storage._guidanceStrength {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      if !_storage._schedule.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._schedule, fieldNumber: 4)
      }
      try { if let v = _storage._cutouts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._prompt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_GuidanceInstanceParameters, rhs: Stabilityai_Platformapis_Generation_V1_GuidanceInstanceParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._models != rhs_storage._models {return false}
        if _storage._guidanceStrength != rhs_storage._guidanceStrength {return false}
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._cutouts != rhs_storage._cutouts {return false}
        if _storage._prompt != rhs_storage._prompt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_GuidanceParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GuidanceParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guidance_preset"),
    2: .same(proto: "instances"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.guidancePreset) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guidancePreset != .none {
      try visitor.visitSingularEnumField(value: self.guidancePreset, fieldNumber: 1)
    }
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_GuidanceParameters, rhs: Stabilityai_Platformapis_Generation_V1_GuidanceParameters) -> Bool {
    if lhs.guidancePreset != rhs.guidancePreset {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_TransformType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diffusion"),
    2: .same(proto: "upscaler"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stabilityai_Platformapis_Generation_V1_DiffusionSampler?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .diffusion(v)
        }
      }()
      case 2: try {
        var v: Stabilityai_Platformapis_Generation_V1_Upscaler?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .upscaler(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .diffusion?: try {
      guard case .diffusion(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .upscaler?: try {
      guard case .upscaler(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformType, rhs: Stabilityai_Platformapis_Generation_V1_TransformType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_ImageParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "width"),
    3: .same(proto: "seed"),
    4: .same(proto: "samples"),
    5: .same(proto: "steps"),
    6: .same(proto: "transform"),
    7: .same(proto: "parameters"),
    8: .standard(proto: "masked_area_init"),
    9: .standard(proto: "weight_method"),
    10: .same(proto: "quantize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._height) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._width) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.seed) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._samples) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._steps) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._transform) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self._maskedAreaInit) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self._weightMethod) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._quantize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._height {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.seed.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.seed, fieldNumber: 3)
    }
    try { if let v = self._samples {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._steps {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._transform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 7)
    }
    try { if let v = self._maskedAreaInit {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._weightMethod {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._quantize {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_ImageParameters, rhs: Stabilityai_Platformapis_Generation_V1_ImageParameters) -> Bool {
    if lhs._height != rhs._height {return false}
    if lhs._width != rhs._width {return false}
    if lhs.seed != rhs.seed {return false}
    if lhs._samples != rhs._samples {return false}
    if lhs._steps != rhs._steps {return false}
    if lhs._transform != rhs._transform {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs._maskedAreaInit != rhs._maskedAreaInit {return false}
    if lhs._weightMethod != rhs._weightMethod {return false}
    if lhs._quantize != rhs._quantize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_ClassifierConcept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassifierConcept"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "concept"),
    2: .same(proto: "threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.concept) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._threshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.concept.isEmpty {
      try visitor.visitSingularStringField(value: self.concept, fieldNumber: 1)
    }
    try { if let v = self._threshold {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_ClassifierConcept, rhs: Stabilityai_Platformapis_Generation_V1_ClassifierConcept) -> Bool {
    if lhs.concept != rhs.concept {return false}
    if lhs._threshold != rhs._threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_ClassifierCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassifierCategory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "concepts"),
    3: .same(proto: "adjustment"),
    4: .same(proto: "action"),
    5: .standard(proto: "classifier_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.concepts) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._adjustment) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._classifierMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.concepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.concepts, fieldNumber: 2)
    }
    try { if let v = self._adjustment {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._classifierMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_ClassifierCategory, rhs: Stabilityai_Platformapis_Generation_V1_ClassifierCategory) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.concepts != rhs.concepts {return false}
    if lhs._adjustment != rhs._adjustment {return false}
    if lhs._action != rhs._action {return false}
    if lhs._classifierMode != rhs._classifierMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_ClassifierParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassifierParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "categories"),
    2: .same(proto: "exceeds"),
    3: .standard(proto: "realized_action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.categories) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.exceeds) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._realizedAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.categories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categories, fieldNumber: 1)
    }
    if !self.exceeds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exceeds, fieldNumber: 2)
    }
    try { if let v = self._realizedAction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_ClassifierParameters, rhs: Stabilityai_Platformapis_Generation_V1_ClassifierParameters) -> Bool {
    if lhs.categories != rhs.categories {return false}
    if lhs.exceeds != rhs.exceeds {return false}
    if lhs._realizedAction != rhs._realizedAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_InterpolateParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InterpolateParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ratios"),
    2: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.ratios) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ratios.isEmpty {
      try visitor.visitPackedFloatField(value: self.ratios, fieldNumber: 1)
    }
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_InterpolateParameters, rhs: Stabilityai_Platformapis_Generation_V1_InterpolateParameters) -> Bool {
    if lhs.ratios != rhs.ratios {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_TransformColorAdjust: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformColorAdjust"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "brightness"),
    2: .same(proto: "contrast"),
    3: .same(proto: "hue"),
    4: .same(proto: "saturation"),
    5: .same(proto: "lightness"),
    6: .standard(proto: "match_image"),
    7: .standard(proto: "match_mode"),
    8: .standard(proto: "noise_amount"),
    9: .standard(proto: "noise_seed"),
  ]

  fileprivate class _StorageClass {
    var _brightness: Float? = nil
    var _contrast: Float? = nil
    var _hue: Float? = nil
    var _saturation: Float? = nil
    var _lightness: Float? = nil
    var _matchImage: Stabilityai_Platformapis_Generation_V1_Artifact? = nil
    var _matchMode: Stabilityai_Platformapis_Generation_V1_ColorMatchMode? = nil
    var _noiseAmount: Float? = nil
    var _noiseSeed: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _brightness = source._brightness
      _contrast = source._contrast
      _hue = source._hue
      _saturation = source._saturation
      _lightness = source._lightness
      _matchImage = source._matchImage
      _matchMode = source._matchMode
      _noiseAmount = source._noiseAmount
      _noiseSeed = source._noiseSeed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._brightness) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._contrast) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._hue) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._saturation) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._lightness) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._matchImage) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._matchMode) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._noiseAmount) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._noiseSeed) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._brightness {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._contrast {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._hue {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._saturation {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._lightness {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._matchImage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._matchMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._noiseAmount {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._noiseSeed {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformColorAdjust, rhs: Stabilityai_Platformapis_Generation_V1_TransformColorAdjust) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._brightness != rhs_storage._brightness {return false}
        if _storage._contrast != rhs_storage._contrast {return false}
        if _storage._hue != rhs_storage._hue {return false}
        if _storage._saturation != rhs_storage._saturation {return false}
        if _storage._lightness != rhs_storage._lightness {return false}
        if _storage._matchImage != rhs_storage._matchImage {return false}
        if _storage._matchMode != rhs_storage._matchMode {return false}
        if _storage._noiseAmount != rhs_storage._noiseAmount {return false}
        if _storage._noiseSeed != rhs_storage._noiseSeed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_TransformDepthCalc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformDepthCalc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blend_weight"),
    2: .standard(proto: "blur_radius"),
    3: .same(proto: "reverse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._blendWeight) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._blurRadius) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blendWeight {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blurRadius {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformDepthCalc, rhs: Stabilityai_Platformapis_Generation_V1_TransformDepthCalc) -> Bool {
    if lhs._blendWeight != rhs._blendWeight {return false}
    if lhs._blurRadius != rhs._blurRadius {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_TransformMatrix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformMatrix"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitPackedFloatField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformMatrix, rhs: Stabilityai_Platformapis_Generation_V1_TransformMatrix) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_TransformResample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformResample"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "border_mode"),
    2: .same(proto: "transform"),
    3: .standard(proto: "prev_transform"),
    4: .standard(proto: "depth_warp"),
    5: .standard(proto: "export_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.borderMode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transform) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._prevTransform) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._depthWarp) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._exportMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.borderMode != .borderReflect {
      try visitor.visitSingularEnumField(value: self.borderMode, fieldNumber: 1)
    }
    try { if let v = self._transform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._prevTransform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._depthWarp {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._exportMask {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformResample, rhs: Stabilityai_Platformapis_Generation_V1_TransformResample) -> Bool {
    if lhs.borderMode != rhs.borderMode {return false}
    if lhs._transform != rhs._transform {return false}
    if lhs._prevTransform != rhs._prevTransform {return false}
    if lhs._depthWarp != rhs._depthWarp {return false}
    if lhs._exportMask != rhs._exportMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_CameraParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CameraParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "camera_type"),
    2: .standard(proto: "near_plane"),
    3: .standard(proto: "far_plane"),
    4: .same(proto: "fov"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.cameraType) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.nearPlane) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.farPlane) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._fov) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.cameraType != .cameraPerspective {
      try visitor.visitSingularEnumField(value: self.cameraType, fieldNumber: 1)
    }
    if self.nearPlane != 0 {
      try visitor.visitSingularFloatField(value: self.nearPlane, fieldNumber: 2)
    }
    if self.farPlane != 0 {
      try visitor.visitSingularFloatField(value: self.farPlane, fieldNumber: 3)
    }
    try { if let v = self._fov {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_CameraParameters, rhs: Stabilityai_Platformapis_Generation_V1_CameraParameters) -> Bool {
    if lhs.cameraType != rhs.cameraType {return false}
    if lhs.nearPlane != rhs.nearPlane {return false}
    if lhs.farPlane != rhs.farPlane {return false}
    if lhs._fov != rhs._fov {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_TransformCameraPose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformCameraPose"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "world_to_view_matrix"),
    2: .standard(proto: "camera_parameters"),
    5: .standard(proto: "do_prefill"),
    8: .standard(proto: "render_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._worldToViewMatrix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cameraParameters) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.doPrefill) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.renderMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._worldToViewMatrix {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cameraParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.doPrefill != false {
      try visitor.visitSingularBoolField(value: self.doPrefill, fieldNumber: 5)
    }
    if self.renderMode != .renderMesh {
      try visitor.visitSingularEnumField(value: self.renderMode, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformCameraPose, rhs: Stabilityai_Platformapis_Generation_V1_TransformCameraPose) -> Bool {
    if lhs._worldToViewMatrix != rhs._worldToViewMatrix {return false}
    if lhs._cameraParameters != rhs._cameraParameters {return false}
    if lhs.doPrefill != rhs.doPrefill {return false}
    if lhs.renderMode != rhs.renderMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_TransformParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "color_adjust"),
    4: .standard(proto: "depth_calc"),
    5: .same(proto: "resample"),
    6: .standard(proto: "camera_pose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Stabilityai_Platformapis_Generation_V1_TransformColorAdjust?
        var hadOneofValue = false
        if let current = self.transform {
          hadOneofValue = true
          if case .colorAdjust(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transform = .colorAdjust(v)
        }
      }()
      case 4: try {
        var v: Stabilityai_Platformapis_Generation_V1_TransformDepthCalc?
        var hadOneofValue = false
        if let current = self.transform {
          hadOneofValue = true
          if case .depthCalc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transform = .depthCalc(v)
        }
      }()
      case 5: try {
        var v: Stabilityai_Platformapis_Generation_V1_TransformResample?
        var hadOneofValue = false
        if let current = self.transform {
          hadOneofValue = true
          if case .resample(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transform = .resample(v)
        }
      }()
      case 6: try {
        var v: Stabilityai_Platformapis_Generation_V1_TransformCameraPose?
        var hadOneofValue = false
        if let current = self.transform {
          hadOneofValue = true
          if case .cameraPose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transform = .cameraPose(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.transform {
    case .colorAdjust?: try {
      guard case .colorAdjust(let v)? = self.transform else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .depthCalc?: try {
      guard case .depthCalc(let v)? = self.transform else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .resample?: try {
      guard case .resample(let v)? = self.transform else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .cameraPose?: try {
      guard case .cameraPose(let v)? = self.transform else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_TransformParameters, rhs: Stabilityai_Platformapis_Generation_V1_TransformParameters) -> Bool {
    if lhs.transform != rhs.transform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_AssetParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "project_id"),
    3: .same(proto: "use"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.use) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .assetPut {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    if self.use != .undefined {
      try visitor.visitSingularEnumField(value: self.use, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_AssetParameters, rhs: Stabilityai_Platformapis_Generation_V1_AssetParameters) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.use != rhs.use {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_AnswerMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnswerMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gpu_id"),
    2: .standard(proto: "cpu_id"),
    3: .standard(proto: "node_id"),
    4: .standard(proto: "engine_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._gpuID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._cpuID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._nodeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._engineID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gpuID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cpuID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nodeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._engineID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_AnswerMeta, rhs: Stabilityai_Platformapis_Generation_V1_AnswerMeta) -> Bool {
    if lhs._gpuID != rhs._gpuID {return false}
    if lhs._cpuID != rhs._cpuID {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._engineID != rhs._engineID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_Answer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Answer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "answer_id"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "received"),
    4: .same(proto: "created"),
    6: .same(proto: "meta"),
    7: .same(proto: "artifacts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.answerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.received) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.created) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.artifacts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.answerID.isEmpty {
      try visitor.visitSingularStringField(value: self.answerID, fieldNumber: 1)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 2)
    }
    if self.received != 0 {
      try visitor.visitSingularUInt64Field(value: self.received, fieldNumber: 3)
    }
    if self.created != 0 {
      try visitor.visitSingularUInt64Field(value: self.created, fieldNumber: 4)
    }
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.artifacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artifacts, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Answer, rhs: Stabilityai_Platformapis_Generation_V1_Answer) -> Bool {
    if lhs.answerID != rhs.answerID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.received != rhs.received {return false}
    if lhs.created != rhs.created {return false}
    if lhs._meta != rhs._meta {return false}
    if lhs.artifacts != rhs.artifacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_AnswerBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnswerBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_id"),
    2: .same(proto: "answers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 1)
    }
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_AnswerBatch, rhs: Stabilityai_Platformapis_Generation_V1_AnswerBatch) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "engine_id"),
    2: .standard(proto: "request_id"),
    3: .standard(proto: "requested_type"),
    4: .same(proto: "prompt"),
    5: .same(proto: "image"),
    7: .same(proto: "classifier"),
    8: .same(proto: "asset"),
    11: .same(proto: "interpolate"),
    12: .same(proto: "transform"),
    6: .same(proto: "conditioner"),
    2047: .same(proto: "extras"),
  ]

  fileprivate class _StorageClass {
    var _engineID: String = String()
    var _requestID: String = String()
    var _requestedType: Stabilityai_Platformapis_Generation_V1_ArtifactType = .artifactNone
    var _prompt: [Stabilityai_Platformapis_Generation_V1_Prompt] = []
    var _params: Stabilityai_Platformapis_Generation_V1_Request.OneOf_Params?
    var _conditioner: Stabilityai_Platformapis_Generation_V1_ConditionerParameters? = nil
    var _extras: SwiftProtobuf.Google_Protobuf_Struct? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _engineID = source._engineID
      _requestID = source._requestID
      _requestedType = source._requestedType
      _prompt = source._prompt
      _params = source._params
      _conditioner = source._conditioner
      _extras = source._extras
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._engineID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._requestedType) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._prompt) }()
        case 5: try {
          var v: Stabilityai_Platformapis_Generation_V1_ImageParameters?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .image(v)
          }
        }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._conditioner) }()
        case 7: try {
          var v: Stabilityai_Platformapis_Generation_V1_ClassifierParameters?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .classifier(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .classifier(v)
          }
        }()
        case 8: try {
          var v: Stabilityai_Platformapis_Generation_V1_AssetParameters?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .asset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .asset(v)
          }
        }()
        case 11: try {
          var v: Stabilityai_Platformapis_Generation_V1_InterpolateParameters?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .interpolate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .interpolate(v)
          }
        }()
        case 12: try {
          var v: Stabilityai_Platformapis_Generation_V1_TransformParameters?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .transform(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .transform(v)
          }
        }()
        case 2047: try { try decoder.decodeSingularMessageField(value: &_storage._extras) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._engineID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._engineID, fieldNumber: 1)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 2)
      }
      if _storage._requestedType != .artifactNone {
        try visitor.visitSingularEnumField(value: _storage._requestedType, fieldNumber: 3)
      }
      if !_storage._prompt.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._prompt, fieldNumber: 4)
      }
      try { if case .image(let v)? = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._conditioner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      switch _storage._params {
      case .classifier?: try {
        guard case .classifier(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .asset?: try {
        guard case .asset(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .interpolate?: try {
        guard case .interpolate(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .transform?: try {
        guard case .transform(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      default: break
      }
      try { if let v = _storage._extras {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2047)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Request, rhs: Stabilityai_Platformapis_Generation_V1_Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._engineID != rhs_storage._engineID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._requestedType != rhs_storage._requestedType {return false}
        if _storage._prompt != rhs_storage._prompt {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._conditioner != rhs_storage._conditioner {return false}
        if _storage._extras != rhs_storage._extras {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_OnStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OnStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "target"),
    3: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._target) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.reason.isEmpty {
      try visitor.visitPackedEnumField(value: self.reason, fieldNumber: 1)
    }
    try { if let v = self._target {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.action.isEmpty {
      try visitor.visitPackedEnumField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_OnStatus, rhs: Stabilityai_Platformapis_Generation_V1_OnStatus) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs._target != rhs._target {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_Stage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Stage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "request"),
    3: .standard(proto: "on_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.onStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.onStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.onStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_Stage, rhs: Stabilityai_Platformapis_Generation_V1_Stage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._request != rhs._request {return false}
    if lhs.onStatus != rhs.onStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Generation_V1_ChainRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "stage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.stage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Generation_V1_ChainRequest, rhs: Stabilityai_Platformapis_Generation_V1_ChainRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
