// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stabilityai/platformapis/project/v1/project.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Stabilityai_Platformapis_Project_V1_ProjectAccess: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Private access, only owner organization can access
  case `private` // = 0

  /// Public access, anyone can access
  case `public` // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .private
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .private
    case 1: self = .public
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .private: return 0
    case .public: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Project_V1_ProjectAccess: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Project_V1_ProjectAccess] = [
    .private,
    .public,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Project_V1_ProjectStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Inactive project
  case inactive // = 0

  /// Active project
  case active // = 1

  /// Deleted project, only set by delete endpoint
  case deleted // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .inactive
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inactive
    case 1: self = .active
    case 2: self = .deleted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .inactive: return 0
    case .active: return 1
    case .deleted: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Project_V1_ProjectStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Project_V1_ProjectStatus] = [
    .inactive,
    .active,
    .deleted,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Project_V1_ProjectAssetUse: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Asset does not have use defined
  case undefined // = 0

  /// Asset is used as an input for the project
  case input // = 1

  /// Asset is an output from the project
  case output // = 2

  /// Asset is an output from an intermediate step of the project
  case intermediate // = 3

  /// Asset is used as the project file for the project
  case project // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .input
    case 2: self = .output
    case 3: self = .intermediate
    case 4: self = .project
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .input: return 1
    case .output: return 2
    case .intermediate: return 3
    case .project: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Project_V1_ProjectAssetUse: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Project_V1_ProjectAssetUse] = [
    .undefined,
    .input,
    .output,
    .intermediate,
    .project,
  ]
}

#endif  // swift(>=4.2)

enum Stabilityai_Platformapis_Project_V1_ProjectSortDir: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Sort direction is not specified, uses default
  case unspecified // = 0

  /// Sort in ascending order
  case asc // = 1

  /// Sort in descending order
  case desc // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .asc
    case 2: self = .desc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .asc: return 1
    case .desc: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stabilityai_Platformapis_Project_V1_ProjectSortDir: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stabilityai_Platformapis_Project_V1_ProjectSortDir] = [
    .unspecified,
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

struct Stabilityai_Platformapis_Project_V1_ProjectAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the asset, UUIDv4
  var id: String = String()

  /// The URI to the asset
  var uri: String = String()

  /// The use of the asset with respect to the project
  var use: Stabilityai_Platformapis_Project_V1_ProjectAssetUse = .undefined

  /// The name of the asset
  var name: String = String()

  /// The asset size in bytes
  var size: UInt64 = 0

  /// Time of asset creation (UTC seconds epoch)
  var createdAt: UInt64 = 0

  /// Time of last asset update (UTC seconds epoch)
  var updatedAt: UInt64 = 0

  /// The request object that is associated with the artifact
  var request: Stabilityai_Platformapis_Generation_V1_Request {
    get {return _request ?? Stabilityai_Platformapis_Generation_V1_Request()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// The tags associated with the asset
  var tags: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Stabilityai_Platformapis_Generation_V1_Request? = nil
}

struct Stabilityai_Platformapis_Project_V1_Project {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project, UUIDv4
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Title of the project
  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  /// The ID of the organization owning the project
  var ownerID: String {
    get {return _storage._ownerID}
    set {_uniqueStorage()._ownerID = newValue}
  }

  /// The access of the project (such as public vs private)
  var access: Stabilityai_Platformapis_Project_V1_ProjectAccess {
    get {return _storage._access}
    set {_uniqueStorage()._access = newValue}
  }

  /// The status of the project (such as active vs inactive)
  var status: Stabilityai_Platformapis_Project_V1_ProjectStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// The size of the project in bytes
  var size: UInt64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// Project file for the project
  var file: Stabilityai_Platformapis_Project_V1_ProjectAsset {
    get {return _storage._file ?? Stabilityai_Platformapis_Project_V1_ProjectAsset()}
    set {_uniqueStorage()._file = newValue}
  }
  /// Returns true if `file` has been explicitly set.
  var hasFile: Bool {return _storage._file != nil}
  /// Clears the value of `file`. Subsequent reads from it will return its default value.
  mutating func clearFile() {_uniqueStorage()._file = nil}

  /// Time of project creation (UTC seconds epoch)
  var createdAt: UInt64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  /// Time of last project update (UTC seconds epoch)
  var updatedAt: UInt64 {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  /// The listing of all assets associated with the project
  var assets: [Stabilityai_Platformapis_Project_V1_ProjectAsset] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stabilityai_Platformapis_Project_V1_CreateProjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// title of the project
  var title: String = String()

  /// The ID of the organization owning the project, empty for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  /// The access of the project (such as public vs private)
  var access: Stabilityai_Platformapis_Project_V1_ProjectAccess = .private

  /// The status of the project (such as active vs inactive)
  var status: Stabilityai_Platformapis_Project_V1_ProjectStatus = .inactive

  /// Project file for the project (if existing, else will create)
  var file: Stabilityai_Platformapis_Project_V1_ProjectAsset {
    get {return _file ?? Stabilityai_Platformapis_Project_V1_ProjectAsset()}
    set {_file = newValue}
  }
  /// Returns true if `file` has been explicitly set.
  var hasFile: Bool {return self._file != nil}
  /// Clears the value of `file`. Subsequent reads from it will return its default value.
  mutating func clearFile() {self._file = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
  fileprivate var _file: Stabilityai_Platformapis_Project_V1_ProjectAsset? = nil
}

struct Stabilityai_Platformapis_Project_V1_UpdateProjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project, UUIDv4
  var id: String = String()

  /// The ID of the organization owning the project, empty for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  /// Title of the project
  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  /// The access of the project (such as public vs private)
  var access: Stabilityai_Platformapis_Project_V1_ProjectAccess {
    get {return _access ?? .private}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  mutating func clearAccess() {self._access = nil}

  /// The status of the project (such as active vs inactive)
  var status: Stabilityai_Platformapis_Project_V1_ProjectStatus {
    get {return _status ?? .inactive}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Project file for the project
  var file: Stabilityai_Platformapis_Project_V1_ProjectAsset {
    get {return _file ?? Stabilityai_Platformapis_Project_V1_ProjectAsset()}
    set {_file = newValue}
  }
  /// Returns true if `file` has been explicitly set.
  var hasFile: Bool {return self._file != nil}
  /// Clears the value of `file`. Subsequent reads from it will return its default value.
  mutating func clearFile() {self._file = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
  fileprivate var _title: String? = nil
  fileprivate var _access: Stabilityai_Platformapis_Project_V1_ProjectAccess? = nil
  fileprivate var _status: Stabilityai_Platformapis_Project_V1_ProjectStatus? = nil
  fileprivate var _file: Stabilityai_Platformapis_Project_V1_ProjectAsset? = nil
}

struct Stabilityai_Platformapis_Project_V1_ListProjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the organization owning the project, empty for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
}

struct Stabilityai_Platformapis_Project_V1_GetProjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project to request, UUIDv4, empty string uses default project
  var id: String = String()

  /// The ID of the organization owning the project, empty for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
}

struct Stabilityai_Platformapis_Project_V1_DeleteProjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project to request, UUIDv4
  var id: String = String()

  /// The ID of the organization owning the project, empty for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
}

struct Stabilityai_Platformapis_Project_V1_QueryAssetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project to request, UUIDv4, empty string uses default project
  var id: String = String()

  /// The ID of the organization owning the assets, unset for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  /// The time (UTC seconds epoch) to start listing assets from, unset for no restriction
  var since: UInt64 {
    get {return _since ?? 0}
    set {_since = newValue}
  }
  /// Returns true if `since` has been explicitly set.
  var hasSince: Bool {return self._since != nil}
  /// Clears the value of `since`. Subsequent reads from it will return its default value.
  mutating func clearSince() {self._since = nil}

  /// The time (UTC seconds epoch) to stop listing assets at, unset for no restriction
  var until: UInt64 {
    get {return _until ?? 0}
    set {_until = newValue}
  }
  /// Returns true if `until` has been explicitly set.
  var hasUntil: Bool {return self._until != nil}
  /// Clears the value of `until`. Subsequent reads from it will return its default value.
  mutating func clearUntil() {self._until = nil}

  /// The maximum number of assets to return, unset for no limit
  var limit: UInt64 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {self._limit = nil}

  /// The key to start from, used to paginate results, unset for no offset
  var startKey: String {
    get {return _startKey ?? String()}
    set {_startKey = newValue}
  }
  /// Returns true if `startKey` has been explicitly set.
  var hasStartKey: Bool {return self._startKey != nil}
  /// Clears the value of `startKey`. Subsequent reads from it will return its default value.
  mutating func clearStartKey() {self._startKey = nil}

  /// The asset usage to filter the assets returned, empty for no filter
  var use: [Stabilityai_Platformapis_Project_V1_ProjectAssetUse] = []

  /// The sort direction based on asset creation time, default is descending
  var sortDir: Stabilityai_Platformapis_Project_V1_ProjectSortDir = .unspecified

  /// The tag values used to filter the assets returned, empty for no filter
  var tags: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
  fileprivate var _since: UInt64? = nil
  fileprivate var _until: UInt64? = nil
  fileprivate var _limit: UInt64? = nil
  fileprivate var _startKey: String? = nil
}

struct Stabilityai_Platformapis_Project_V1_QueryAssetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The assets returned by the query
  var assets: [Stabilityai_Platformapis_Project_V1_ProjectAsset] = []

  /// The last asset key returned when the results were limited, unset when not limited
  var lastKey: String {
    get {return _lastKey ?? String()}
    set {_lastKey = newValue}
  }
  /// Returns true if `lastKey` has been explicitly set.
  var hasLastKey: Bool {return self._lastKey != nil}
  /// Clears the value of `lastKey`. Subsequent reads from it will return its default value.
  mutating func clearLastKey() {self._lastKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastKey: String? = nil
}

struct Stabilityai_Platformapis_Project_V1_TagAssetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project to request, UUIDv4, empty string uses default project
  var id: String = String()

  /// The ID of the organization owning the assets, unset for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  /// The IDs of the assets to tag in the project, UUIDv4, limit 1000
  var assetIds: [String] = []

  /// The tags to add to the assets
  var tags: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
}

struct Stabilityai_Platformapis_Project_V1_TagAssetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project, UUIDv4
  var id: String = String()

  /// The ID of the organization owning the project
  var ownerID: String = String()

  /// The IDs of the assets updated in the project, UUIDv4, limit 1000
  var assetIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stabilityai_Platformapis_Project_V1_UntagAssetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project to request, UUIDv4, empty string uses default project
  var id: String = String()

  /// The ID of the organization owning the assets, unset for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  /// The IDs of the assets to tag in the project, UUIDv4, limit 1000
  var assetIds: [String] = []

  /// The keys of the tags to remove from the assets
  var tagKeys: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
}

struct Stabilityai_Platformapis_Project_V1_UntagAssetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project, UUIDv4
  var id: String = String()

  /// The ID of the organization owning the project
  var ownerID: String = String()

  /// The IDs of the assets updated in the project, UUIDv4, limit 1000
  var assetIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stabilityai_Platformapis_Project_V1_DeleteAssetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project to request, UUIDv4, empty string uses default project
  var id: String = String()

  /// The ID of the organization owning the project, unset for default org for user
  var ownerID: String {
    get {return _ownerID ?? String()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  /// The IDs of the assets to delete from the project, UUIDv4, limit 1000
  var assetIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: String? = nil
}

struct Stabilityai_Platformapis_Project_V1_DeleteAssetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project, UUIDv4
  var id: String = String()

  /// The ID of the organization owning the project
  var ownerID: String = String()

  /// The IDs of the assets deleted from the project, UUIDv4, limit 1000
  var assetIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stabilityai_Platformapis_Project_V1_ProjectAccess: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_ProjectStatus: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_ProjectAssetUse: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_ProjectSortDir: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_ProjectAsset: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_Project: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_CreateProjectRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_UpdateProjectRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_ListProjectRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_GetProjectRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_DeleteProjectRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_QueryAssetsRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_QueryAssetsResponse: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_TagAssetsRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_TagAssetsResponse: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_UntagAssetsRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_UntagAssetsResponse: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_DeleteAssetsRequest: @unchecked Sendable {}
extension Stabilityai_Platformapis_Project_V1_DeleteAssetsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stabilityai.platformapis.project.v1"

extension Stabilityai_Platformapis_Project_V1_ProjectAccess: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROJECT_ACCESS_PRIVATE"),
    1: .same(proto: "PROJECT_ACCESS_PUBLIC"),
  ]
}

extension Stabilityai_Platformapis_Project_V1_ProjectStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROJECT_STATUS_INACTIVE"),
    1: .same(proto: "PROJECT_STATUS_ACTIVE"),
    2: .same(proto: "PROJECT_STATUS_DELETED"),
  ]
}

extension Stabilityai_Platformapis_Project_V1_ProjectAssetUse: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROJECT_ASSET_USE_UNDEFINED"),
    1: .same(proto: "PROJECT_ASSET_USE_INPUT"),
    2: .same(proto: "PROJECT_ASSET_USE_OUTPUT"),
    3: .same(proto: "PROJECT_ASSET_USE_INTERMEDIATE"),
    4: .same(proto: "PROJECT_ASSET_USE_PROJECT"),
  ]
}

extension Stabilityai_Platformapis_Project_V1_ProjectSortDir: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROJECT_SORT_DIR_UNSPECIFIED"),
    1: .same(proto: "PROJECT_SORT_DIR_ASC"),
    2: .same(proto: "PROJECT_SORT_DIR_DESC"),
  ]
}

extension Stabilityai_Platformapis_Project_V1_ProjectAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProjectAsset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uri"),
    3: .same(proto: "use"),
    4: .same(proto: "name"),
    5: .same(proto: "size"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "updated_at"),
    8: .same(proto: "request"),
    9: .same(proto: "tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.use) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.updatedAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if self.use != .undefined {
      try visitor.visitSingularEnumField(value: self.use, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 5)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 6)
    }
    if self.updatedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.updatedAt, fieldNumber: 7)
    }
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_ProjectAsset, rhs: Stabilityai_Platformapis_Project_V1_ProjectAsset) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.use != rhs.use {return false}
    if lhs.name != rhs.name {return false}
    if lhs.size != rhs.size {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs._request != rhs._request {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_Project: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Project"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .standard(proto: "owner_id"),
    4: .same(proto: "access"),
    5: .same(proto: "status"),
    6: .same(proto: "size"),
    7: .same(proto: "file"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "updated_at"),
    10: .same(proto: "assets"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _title: String = String()
    var _ownerID: String = String()
    var _access: Stabilityai_Platformapis_Project_V1_ProjectAccess = .private
    var _status: Stabilityai_Platformapis_Project_V1_ProjectStatus = .inactive
    var _size: UInt64 = 0
    var _file: Stabilityai_Platformapis_Project_V1_ProjectAsset? = nil
    var _createdAt: UInt64 = 0
    var _updatedAt: UInt64 = 0
    var _assets: [Stabilityai_Platformapis_Project_V1_ProjectAsset] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _title = source._title
      _ownerID = source._ownerID
      _access = source._access
      _status = source._status
      _size = source._size
      _file = source._file
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _assets = source._assets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._ownerID) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._access) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._size) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._file) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._createdAt) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._updatedAt) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._assets) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._ownerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerID, fieldNumber: 3)
      }
      if _storage._access != .private {
        try visitor.visitSingularEnumField(value: _storage._access, fieldNumber: 4)
      }
      if _storage._status != .inactive {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._size != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._size, fieldNumber: 6)
      }
      try { if let v = _storage._file {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._createdAt != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._createdAt, fieldNumber: 8)
      }
      if _storage._updatedAt != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._updatedAt, fieldNumber: 9)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._assets, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_Project, rhs: Stabilityai_Platformapis_Project_V1_Project) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._ownerID != rhs_storage._ownerID {return false}
        if _storage._access != rhs_storage._access {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._file != rhs_storage._file {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._assets != rhs_storage._assets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_CreateProjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateProjectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "owner_id"),
    3: .same(proto: "access"),
    4: .same(proto: "status"),
    5: .same(proto: "file"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.access) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._file) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.access != .private {
      try visitor.visitSingularEnumField(value: self.access, fieldNumber: 3)
    }
    if self.status != .inactive {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try { if let v = self._file {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_CreateProjectRequest, rhs: Stabilityai_Platformapis_Project_V1_CreateProjectRequest) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.access != rhs.access {return false}
    if lhs.status != rhs.status {return false}
    if lhs._file != rhs._file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_UpdateProjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateProjectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
    3: .same(proto: "title"),
    4: .same(proto: "access"),
    5: .same(proto: "status"),
    6: .same(proto: "file"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._access) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._file) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._access {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._file {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_UpdateProjectRequest, rhs: Stabilityai_Platformapis_Project_V1_UpdateProjectRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs._title != rhs._title {return false}
    if lhs._access != rhs._access {return false}
    if lhs._status != rhs._status {return false}
    if lhs._file != rhs._file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_ListProjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListProjectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_ListProjectRequest, rhs: Stabilityai_Platformapis_Project_V1_ListProjectRequest) -> Bool {
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_GetProjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetProjectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_GetProjectRequest, rhs: Stabilityai_Platformapis_Project_V1_GetProjectRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_DeleteProjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteProjectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_DeleteProjectRequest, rhs: Stabilityai_Platformapis_Project_V1_DeleteProjectRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_QueryAssetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAssetsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
    3: .same(proto: "since"),
    4: .same(proto: "until"),
    5: .same(proto: "limit"),
    6: .standard(proto: "start_key"),
    7: .same(proto: "use"),
    8: .standard(proto: "sort_dir"),
    9: .same(proto: "tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._since) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._until) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._limit) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._startKey) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.use) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.sortDir) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._since {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._until {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._startKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    if !self.use.isEmpty {
      try visitor.visitPackedEnumField(value: self.use, fieldNumber: 7)
    }
    if self.sortDir != .unspecified {
      try visitor.visitSingularEnumField(value: self.sortDir, fieldNumber: 8)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_QueryAssetsRequest, rhs: Stabilityai_Platformapis_Project_V1_QueryAssetsRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs._since != rhs._since {return false}
    if lhs._until != rhs._until {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._startKey != rhs._startKey {return false}
    if lhs.use != rhs.use {return false}
    if lhs.sortDir != rhs.sortDir {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_QueryAssetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAssetsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assets"),
    2: .standard(proto: "last_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._lastKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 1)
    }
    try { if let v = self._lastKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_QueryAssetsResponse, rhs: Stabilityai_Platformapis_Project_V1_QueryAssetsResponse) -> Bool {
    if lhs.assets != rhs.assets {return false}
    if lhs._lastKey != rhs._lastKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_TagAssetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TagAssetsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
    3: .standard(proto: "asset_ids"),
    4: .same(proto: "tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetIds) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.assetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetIds, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_TagAssetsRequest, rhs: Stabilityai_Platformapis_Project_V1_TagAssetsRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.assetIds != rhs.assetIds {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_TagAssetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TagAssetsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
    3: .standard(proto: "asset_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 2)
    }
    if !self.assetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_TagAssetsResponse, rhs: Stabilityai_Platformapis_Project_V1_TagAssetsResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.assetIds != rhs.assetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_UntagAssetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UntagAssetsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
    3: .standard(proto: "asset_ids"),
    4: .standard(proto: "tag_keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetIds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.tagKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.assetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetIds, fieldNumber: 3)
    }
    if !self.tagKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_UntagAssetsRequest, rhs: Stabilityai_Platformapis_Project_V1_UntagAssetsRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.assetIds != rhs.assetIds {return false}
    if lhs.tagKeys != rhs.tagKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_UntagAssetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UntagAssetsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
    3: .standard(proto: "asset_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 2)
    }
    if !self.assetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_UntagAssetsResponse, rhs: Stabilityai_Platformapis_Project_V1_UntagAssetsResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.assetIds != rhs.assetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_DeleteAssetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAssetsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
    3: .standard(proto: "asset_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ownerID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._ownerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.assetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_DeleteAssetsRequest, rhs: Stabilityai_Platformapis_Project_V1_DeleteAssetsRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.assetIds != rhs.assetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stabilityai_Platformapis_Project_V1_DeleteAssetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAssetsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_id"),
    3: .standard(proto: "asset_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 2)
    }
    if !self.assetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stabilityai_Platformapis_Project_V1_DeleteAssetsResponse, rhs: Stabilityai_Platformapis_Project_V1_DeleteAssetsResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.assetIds != rhs.assetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
